name: Unity Build

on:
  workflow_call:
    inputs:
      repository:
        description: 'Repository to checkout (for fork PRs)'
        type: string
        required: false
        default: ''
      ref:
        description: 'Git ref to checkout'
        type: string
        required: false
        default: ''
      os:
        description: 'Operating system (macos or windows)'
        type: string
        required: true
      unity-version:
        description: 'Unity version pattern (e.g., 2021.3, 6000.2)'
        type: string
        required: true
      web-framework-version:
        description: '@apps-in-toss/web-framework version for BuildConfig'
        type: string
        required: false
        default: ''
      run-build:
        description: 'Run Unity WebGL build'
        type: boolean
        required: false
        default: true
      run-e2e-test:
        description: 'Run E2E tests after build'
        type: boolean
        required: false
        default: false
      run-benchmark:
        description: 'Run benchmark tests'
        type: boolean
        required: false
        default: false
      sdk-version:
        description: 'SDK version for artifact naming (bulk release)'
        type: string
        required: false
        default: ''
      sdk-version-override:
        description: 'Override SDK version in package.json (for compatibility testing)'
        type: string
        required: false
        default: ''
      run-unit-test:
        description: 'Run Unity EditMode unit tests before build'
        type: boolean
        required: false
        default: false
      clean-library:
        description: 'Clean Unity Library cache'
        type: boolean
        required: false
        default: false
      test-level:
        description: 'Test level: 0=editmode, 1=build+validation, 2=full-e2e'
        type: string
        required: false
        default: '2'
    secrets:
      AIT_AD_INTERSTITIAL_ID:
        description: 'Interstitial ad ID for testing'
        required: false
      AIT_AD_REWARDED_ID:
        description: 'Rewarded ad ID for testing'
        required: false
    outputs:
      artifact-name:
        description: 'Uploaded artifact name'
        value: ${{ jobs.build.outputs.artifact-name }}
      unity-version-full:
        description: 'Detected full Unity version'
        value: ${{ jobs.build.outputs.unity-version-full }}

jobs:
  build:
    name: Build (${{ inputs.os }}, Unity ${{ inputs.unity-version }})
    runs-on: ${{ inputs.os == 'macos' && fromJSON('["self-hosted", "macOS", "ARM64"]') || fromJSON('["self-hosted", "Windows", "X64", "enabled"]') }}
    timeout-minutes: 60
    concurrency:
      group: unity-build-${{ inputs.ref || github.sha }}-${{ inputs.os }}-${{ inputs.unity-version }}
      cancel-in-progress: true

    outputs:
      artifact-name: ${{ steps.artifact.outputs.name }}
      unity-version-full: ${{ steps.unity.outputs.UNITY_VERSION }}

    steps:
      # =====================================================
      # Windows 전용 설정
      # =====================================================
      - name: Configure Git Long Paths (Windows)
        if: inputs.os == 'windows'
        shell: cmd
        run: |
          @echo off
          setlocal enabledelayedexpansion
          set MAX_RETRIES=5
          set RETRY=0
          :retry_loop
          git config --global core.longPaths true 2>nul && (
            echo Git longPaths configured successfully
            exit /b 0
          )
          set /a RETRY+=1
          if !RETRY! LSS %MAX_RETRIES% (
            echo Retry !RETRY!/%MAX_RETRIES%...
            timeout /t 2 /nobreak >nul
            goto retry_loop
          )
          echo Git longPaths configuration completed
          exit /b 0

      # =====================================================
      # Checkout
      # =====================================================
      - name: Checkout Repository
        uses: actions/checkout@v6
        with:
          repository: ${{ inputs.repository || github.repository }}
          ref: ${{ inputs.ref || github.ref }}

      # =====================================================
      # SDK 버전 오버라이드 (런타임 호환성 테스트용)
      # SDK 코드는 재생성하지 않고, BuildConfig의 web-framework 버전만 변경
      # 이를 통해 현재 SDK 코드가 다른 버전의 web-framework와 호환되는지 테스트
      # =====================================================
      - name: Override SDK Version
        if: inputs.sdk-version-override != ''
        shell: bash
        run: |
          OVERRIDE_VERSION="${{ inputs.sdk-version-override }}"
          PACKAGE_JSON="package.json"

          echo "=== SDK Version Override (BuildConfig Only) ==="
          echo "Target SDK version: ${OVERRIDE_VERSION}"
          echo ""
          echo "NOTE: SDK 코드는 재생성하지 않고 현재 저장소의 코드를 사용합니다."
          echo "      BuildConfig의 web-framework 버전만 변경하여 런타임 호환성을 테스트합니다."
          echo ""

          # 1. package.json 버전 변경 (메타데이터용)
          echo "=== Updating package.json version ==="
          echo "Original version: $(grep '"version"' $PACKAGE_JSON)"
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            sed -i '' "s/\"version\": \"[^\"]*\"/\"version\": \"${OVERRIDE_VERSION}\"/" $PACKAGE_JSON
          else
            sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"${OVERRIDE_VERSION}\"/" $PACKAGE_JSON
          fi
          echo "Overridden version: $(grep '"version"' $PACKAGE_JSON)"

          # 2. BuildConfig의 web-framework 버전 동기화
          echo ""
          echo "=== Syncing BuildConfig web-framework version ==="
          BUILDCONFIG_PKG="WebGLTemplates/AITTemplate/BuildConfig~/package.json"
          if [[ "$RUNNER_OS" == "macOS" ]]; then
            sed -i '' 's/"@apps-in-toss\/web-framework": "[^"]*"/"@apps-in-toss\/web-framework": "'"${OVERRIDE_VERSION}"'"/' "$BUILDCONFIG_PKG"
          else
            sed -i 's/"@apps-in-toss\/web-framework": "[^"]*"/"@apps-in-toss\/web-framework": "'"${OVERRIDE_VERSION}"'"/' "$BUILDCONFIG_PKG"
          fi
          echo "BuildConfig updated:"
          grep "web-framework" "$BUILDCONFIG_PKG"

          # 3. 현재 SDK 파일 확인
          echo ""
          echo "=== Current SDK files (not regenerated) ==="
          ls -la Runtime/SDK/ | head -20

          echo ""
          echo "=== Version Info ==="
          echo "SDK version override: ${OVERRIDE_VERSION}"
          echo "SDK code: Using current repository version (not regenerated)"

      # =====================================================
      # Windows Defender 제외 (Windows)
      # =====================================================
      - name: Exclude Project from Windows Defender (Windows)
        if: inputs.os == 'windows'
        shell: powershell
        continue-on-error: true
        run: |
          $paths = @(
            '${{ github.workspace }}',
            'C:\Program Files\Unity',
            '${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}\ait-build',
            '${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}\webgl',
            '${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}\Library'
          )

          $successCount = 0
          foreach ($path in $paths) {
            try {
              Add-MpPreference -ExclusionPath $path -ErrorAction Stop
              $successCount++
            } catch {
              Write-Host "::warning::Failed to add exclusion for: $path - $_"
            }
          }

          if ($successCount -eq 0) {
            Write-Host "::warning::Windows Defender 제외 설정 실패 - 빌드 성능 저하 가능"
          } else {
            Write-Host "Defender exclusions configured: $successCount/$($paths.Count) paths"
          }

          try {
            $exclusions = Get-MpPreference | Select-Object -ExpandProperty ExclusionPath
            Write-Host "Current exclusion paths: $($exclusions -join ', ')"
          } catch {
            Write-Host "Cannot read Defender preferences"
          }

      # =====================================================
      # 이전 빌드 정리
      # =====================================================
      - name: Clean Previous Build Artifacts (macOS)
        if: inputs.os == 'macos' && (inputs.test-level || '2') != '0'
        run: |
          PROJECT_PATH="Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}"
          echo "Cleaning previous build artifacts..."
          rm -rf "${PROJECT_PATH}/ait-build" 2>/dev/null || true
          rm -rf "${PROJECT_PATH}/webgl" 2>/dev/null || true
          if [ "${{ inputs.clean-library }}" = "true" ]; then
            echo "Cleaning Library cache (requested via input)..."
            rm -rf "${PROJECT_PATH}/Library" 2>/dev/null || true
          fi
          echo "Done."

      - name: Clean Previous Build Artifacts (Windows)
        if: inputs.os == 'windows' && (inputs.test-level || '2') != '0'
        shell: cmd
        run: |
          @echo off
          set "PROJECT_PATH=Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}"
          set "CLEAN_LIBRARY=${{ inputs.clean-library }}"
          echo Cleaning previous build artifacts...
          if exist "%PROJECT_PATH%\ait-build" rmdir /s /q "%PROJECT_PATH%\ait-build"
          if exist "%PROJECT_PATH%\webgl" rmdir /s /q "%PROJECT_PATH%\webgl"
          if "%CLEAN_LIBRARY%"=="true" (
            echo Cleaning Library cache requested via input...
            if exist "%PROJECT_PATH%\Library" rmdir /s /q "%PROJECT_PATH%\Library"
          )
          echo Done.

      # =====================================================
      # Unity 설치 감지
      # =====================================================
      - name: Detect Unity Installation (macOS)
        if: inputs.os == 'macos'
        id: unity-macos
        run: |
          UNITY_BASE="/Applications/Unity/Hub/Editor"
          UNITY_VERSION_PATTERN="${{ inputs.unity-version }}"

          echo "Searching for Unity ${UNITY_VERSION_PATTERN}.x in ${UNITY_BASE}..."

          UNITY_DIR=$(ls -d "${UNITY_BASE}/${UNITY_VERSION_PATTERN}"* 2>/dev/null | sort -rV | head -1)

          if [ -z "$UNITY_DIR" ]; then
            echo "::error::Unity ${UNITY_VERSION_PATTERN}.x not found"
            echo "Available versions:"
            ls -la "${UNITY_BASE}" 2>/dev/null || echo "Unity Hub Editor directory not found"
            exit 1
          fi

          UNITY_PATH="${UNITY_DIR}/Unity.app/Contents/MacOS/Unity"

          if [ ! -f "$UNITY_PATH" ]; then
            echo "::error::Unity executable not found at ${UNITY_PATH}"
            exit 1
          fi

          DETECTED_VERSION=$(basename "${UNITY_DIR}")
          echo "Found Unity ${DETECTED_VERSION}"
          echo "  Path: ${UNITY_PATH}"

          echo "UNITY_PATH=${UNITY_PATH}" >> $GITHUB_OUTPUT
          echo "UNITY_VERSION=${DETECTED_VERSION}" >> $GITHUB_OUTPUT

      - name: Detect Unity Installation (Windows)
        if: inputs.os == 'windows'
        id: unity-windows
        shell: cmd
        run: |
          @echo off
          setlocal enabledelayedexpansion

          set "UNITY_BASE=C:\Program Files\Unity\Hub\Editor"
          set "VERSION_PATTERN=${{ inputs.unity-version }}"

          echo Searching for Unity %VERSION_PATTERN%.x in %UNITY_BASE%...

          set "UNITY_DIR="
          for /d %%d in ("%UNITY_BASE%\%VERSION_PATTERN%*") do (
            set "UNITY_DIR=%%d"
          )

          if not defined UNITY_DIR (
            echo ::error::Unity %VERSION_PATTERN%.x not found
            echo Available versions:
            dir /b "%UNITY_BASE%" 2>nul
            exit /b 1
          )

          set "UNITY_PATH=%UNITY_DIR%\Editor\Unity.exe"

          if not exist "%UNITY_PATH%" (
            echo ::error::Unity executable not found at %UNITY_PATH%
            exit /b 1
          )

          for %%i in ("%UNITY_DIR%") do set "DETECTED_VERSION=%%~nxi"
          echo Found Unity %DETECTED_VERSION%
          echo   Path: %UNITY_PATH%

          echo UNITY_PATH=%UNITY_PATH%>> %GITHUB_OUTPUT%
          echo UNITY_VERSION=%DETECTED_VERSION%>> %GITHUB_OUTPUT%

      - name: Set Unity Outputs
        id: unity
        shell: bash
        run: |
          if [ "${{ inputs.os }}" = "macos" ]; then
            echo "UNITY_PATH=${{ steps.unity-macos.outputs.UNITY_PATH }}" >> $GITHUB_OUTPUT
            echo "UNITY_VERSION=${{ steps.unity-macos.outputs.UNITY_VERSION }}" >> $GITHUB_OUTPUT
          else
            echo "UNITY_PATH=${{ steps.unity-windows.outputs.UNITY_PATH }}" >> $GITHUB_OUTPUT
            echo "UNITY_VERSION=${{ steps.unity-windows.outputs.UNITY_VERSION }}" >> $GITHUB_OUTPUT
          fi

      # =====================================================
      # BuildConfig 버전 업데이트 (선택적)
      # =====================================================
      - name: Update BuildConfig SDK Version
        if: inputs.web-framework-version != ''
        shell: bash
        run: |
          VERSION="${{ inputs.web-framework-version }}"
          BUILD_CONFIG_DIR="WebGLTemplates/AITTemplate/BuildConfig~"
          BUILD_CONFIG="${BUILD_CONFIG_DIR}/package.json"
          LOCK_FILE="${BUILD_CONFIG_DIR}/pnpm-lock.yaml"

          echo "Updating @apps-in-toss/web-framework to ${VERSION}"

          # sed로 버전 업데이트 (macOS/Windows 호환)
          if [ "${{ inputs.os }}" = "macos" ]; then
            sed -i '' 's/"@apps-in-toss\/web-framework": "[^"]*"/"@apps-in-toss\/web-framework": "'"$VERSION"'"/' "$BUILD_CONFIG"
          else
            sed -i 's/"@apps-in-toss\/web-framework": "[^"]*"/"@apps-in-toss\/web-framework": "'"$VERSION"'"/' "$BUILD_CONFIG"
          fi

          echo "Updated BuildConfig:"
          cat "$BUILD_CONFIG"

          # pnpm-lock.yaml 삭제 후 재생성 (frozen-lockfile 호환성 유지)
          rm -f "$LOCK_FILE"
          echo "Regenerating pnpm-lock.yaml..."
          cd "$BUILD_CONFIG_DIR"
          npx pnpm@9 install --lockfile-only
          echo "pnpm-lock.yaml regenerated"

      # =====================================================
      # 광고 ID 치환 (빌드 전)
      # =====================================================
      - name: Inject Ad IDs (macOS)
        if: inputs.os == 'macos' && inputs.run-build && (inputs.test-level || '2') != '0'
        env:
          AIT_AD_INTERSTITIAL_ID: ${{ secrets.AIT_AD_INTERSTITIAL_ID }}
          AIT_AD_REWARDED_ID: ${{ secrets.AIT_AD_REWARDED_ID }}
        run: |
          AD_TESTER="Tests~/E2E/SharedScripts/Runtime/AdV2Tester.cs"

          # SharedScripts가 없으면 스킵 (릴리즈 빌드에서는 제거됨)
          if [ ! -f "$AD_TESTER" ]; then
            echo "SharedScripts not found (release build), skipping ad ID injection"
            exit 0
          fi

          if [ -n "$AIT_AD_INTERSTITIAL_ID" ]; then
            echo "Injecting interstitial ad ID..."
            sed -i '' 's/ait-ad-test-interstitial-id/'"$AIT_AD_INTERSTITIAL_ID"'/g' "$AD_TESTER"
          fi

          if [ -n "$AIT_AD_REWARDED_ID" ]; then
            echo "Injecting rewarded ad ID..."
            sed -i '' 's/ait-ad-test-rewarded-id/'"$AIT_AD_REWARDED_ID"'/g' "$AD_TESTER"
          fi

          echo "Ad IDs injected successfully"

      - name: Inject Ad IDs (Windows)
        if: inputs.os == 'windows' && inputs.run-build && (inputs.test-level || '2') != '0'
        shell: powershell
        env:
          AIT_AD_INTERSTITIAL_ID: ${{ secrets.AIT_AD_INTERSTITIAL_ID }}
          AIT_AD_REWARDED_ID: ${{ secrets.AIT_AD_REWARDED_ID }}
        run: |
          $adTester = "Tests~\E2E\SharedScripts\Runtime\AdV2Tester.cs"

          # SharedScripts가 없으면 스킵 (릴리즈 빌드에서는 제거됨)
          if (-not (Test-Path $adTester)) {
            Write-Host "SharedScripts not found (release build), skipping ad ID injection"
            exit 0
          }

          $content = Get-Content $adTester -Raw

          if ($env:AIT_AD_INTERSTITIAL_ID) {
            Write-Host "Injecting interstitial ad ID..."
            $content = $content -replace 'ait-ad-test-interstitial-id', $env:AIT_AD_INTERSTITIAL_ID
          }

          if ($env:AIT_AD_REWARDED_ID) {
            Write-Host "Injecting rewarded ad ID..."
            $content = $content -replace 'ait-ad-test-rewarded-id', $env:AIT_AD_REWARDED_ID
          }

          Set-Content $adTester -Value $content -NoNewline
          Write-Host "Ad IDs injected successfully"

      # =====================================================
      # EditMode 테스트 (Level 0+, 빌드 없이 C# 순수 로직 검증)
      # =====================================================
      - name: Run EditMode Tests (macOS)
        if: inputs.os == 'macos' && inputs.run-e2e-test
        run: |
          UNITY_PATH="${{ steps.unity.outputs.UNITY_PATH }}"
          PROJECT_PATH="${{ github.workspace }}/Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}"

          echo "Running EditMode Tests..."
          echo "Unity Version: ${{ steps.unity.outputs.UNITY_VERSION }}"

          "$UNITY_PATH" -batchmode -nographics \
            -projectPath "$PROJECT_PATH" \
            -runTests -testPlatform EditMode \
            -testResults "$PROJECT_PATH/editmode-results.xml" \
            -logFile - 2>&1 || true

          # Unity Test Runner는 테스트 실패 시 exit code 2를 반환
          # editmode-results.xml을 파싱하여 실제 실패 여부 확인
          if [ -f "$PROJECT_PATH/editmode-results.xml" ]; then
            echo "EditMode test results:"
            if grep -q 'result="Failed"' "$PROJECT_PATH/editmode-results.xml"; then
              echo "::error::EditMode tests failed"
              grep 'result="Failed"' "$PROJECT_PATH/editmode-results.xml" | head -20
              exit 1
            else
              PASSED=$(grep -o 'result="Passed"' "$PROJECT_PATH/editmode-results.xml" | wc -l | tr -d ' ')
              echo "✓ EditMode tests passed (${PASSED} tests)"
            fi
          else
            echo "::warning::EditMode test results file not found (tests may not have run)"
          fi

      - name: Run EditMode Tests (Windows)
        if: inputs.os == 'windows' && inputs.run-e2e-test
        shell: powershell
        run: |
          $unityPath = "${{ steps.unity.outputs.UNITY_PATH }}"
          $projectPath = "${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}"

          Write-Host "Running EditMode Tests..."
          Write-Host "Unity Version: ${{ steps.unity.outputs.UNITY_VERSION }}"

          $logFile = "$env:TEMP\unity-editmode-${{ inputs.unity-version }}.log"

          $proc = Start-Process -FilePath $unityPath -ArgumentList @(
            "-batchmode", "-nographics",
            "-projectPath", $projectPath,
            "-runTests", "-testPlatform", "EditMode",
            "-testResults", "$projectPath\editmode-results.xml",
            "-logFile", $logFile
          ) -PassThru -NoNewWindow

          # 로그 실시간 출력
          $logReader = $null
          while (-not $proc.HasExited) {
            Start-Sleep -Seconds 3
            if (-not $logReader -and (Test-Path $logFile)) {
              $logReader = [System.IO.StreamReader]::new(
                [System.IO.FileStream]::new($logFile, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
              )
            }
            if ($logReader) {
              $chunk = $logReader.ReadToEnd()
              if ($chunk) { Write-Host $chunk -NoNewline }
            }
          }
          $proc.WaitForExit()

          if ($logReader) {
            $chunk = $logReader.ReadToEnd()
            if ($chunk) { Write-Host $chunk -NoNewline }
            $logReader.Close()
          }

          # 결과 확인
          $resultsFile = "$projectPath\editmode-results.xml"
          if (Test-Path $resultsFile) {
            $content = Get-Content $resultsFile -Raw
            if ($content -match 'result="Failed"') {
              Write-Host "::error::EditMode tests failed"
              exit 1
            } else {
              $passed = ([regex]::Matches($content, 'result="Passed"')).Count
              Write-Host "EditMode tests passed ($passed tests)"
            }
          } else {
            Write-Host "::warning::EditMode test results file not found"
          }

      - name: Upload EditMode Test Results
        if: inputs.run-e2e-test && always()
        uses: actions/upload-artifact@v6
        with:
          name: editmode-results-${{ inputs.os }}-${{ inputs.unity-version }}
          path: Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/editmode-results.xml
          if-no-files-found: ignore
          retention-days: 7

      # =====================================================
      # Unity 빌드 락 획득 (같은 Unity 버전 동시 빌드 방지)
      # 같은 물리 머신에서 여러 Runner가 동일 Unity 버전을 빌드하면
      # 라이선스 충돌이 발생하므로, 파일 락으로 직렬화합니다.
      # =====================================================
      - name: Acquire Unity Build Lock (macOS)
        if: inputs.os == 'macos' && inputs.run-build && (inputs.test-level || '2') != '0'
        id: lock-macos
        run: |
          LOCK_DIR="/tmp/unity-build-lock-${{ inputs.unity-version }}"
          echo "LOCK_DIR=${LOCK_DIR}" >> $GITHUB_OUTPUT

          echo "Acquiring lock: ${LOCK_DIR}"
          WAIT_SECONDS=0
          MAX_WAIT=3600  # 최대 1시간 대기

          while ! mkdir "${LOCK_DIR}" 2>/dev/null; do
            if [ $WAIT_SECONDS -ge $MAX_WAIT ]; then
              echo "::error::Lock acquisition timed out after ${MAX_WAIT}s"
              exit 1
            fi

            # Stale lock 감지: 락 디렉토리가 2시간 이상 된 경우 강제 해제
            if [ -d "${LOCK_DIR}" ]; then
              LOCK_AGE=$(( $(date +%s) - $(stat -f %m "${LOCK_DIR}") ))
              if [ $LOCK_AGE -gt 7200 ]; then
                echo "::warning::Stale lock detected (age: ${LOCK_AGE}s), removing..."
                rmdir "${LOCK_DIR}" 2>/dev/null || rm -rf "${LOCK_DIR}"
                continue
              fi
            fi

            if [ $((WAIT_SECONDS % 60)) -eq 0 ]; then
              echo "Waiting for Unity ${{ inputs.unity-version }} lock... (${WAIT_SECONDS}s elapsed)"
            fi
            sleep 10
            WAIT_SECONDS=$((WAIT_SECONDS + 10))
          done

          echo "Lock acquired after ${WAIT_SECONDS}s"

      - name: Acquire Unity Build Lock (Windows)
        if: inputs.os == 'windows' && inputs.run-build && (inputs.test-level || '2') != '0'
        id: lock-windows
        shell: powershell
        run: |
          $lockFile = "C:\unity-build-lock-${{ inputs.unity-version }}.lock"
          echo "LOCK_FILE=$lockFile" >> $env:GITHUB_OUTPUT

          Write-Host "Acquiring lock: $lockFile"
          $waitSeconds = 0
          $maxWait = 3600  # 최대 1시간 대기

          while ($true) {
            try {
              # Exclusive create: 파일이 이미 존재하면 예외 발생
              $fs = [System.IO.File]::Open($lockFile, [System.IO.FileMode]::CreateNew, [System.IO.FileAccess]::Write)
              $fs.Close()
              break
            } catch [System.IO.IOException] {
              # 파일이 이미 존재 = 다른 빌드가 진행 중
            }

            if ($waitSeconds -ge $maxWait) {
              Write-Host "::error::Lock acquisition timed out after ${maxWait}s"
              exit 1
            }

            # Stale lock 감지: 2시간 이상 된 락 강제 해제
            if (Test-Path $lockFile) {
              $lockAge = (New-TimeSpan -Start (Get-Item $lockFile).LastWriteTime -End (Get-Date)).TotalSeconds
              if ($lockAge -gt 7200) {
                Write-Host "::warning::Stale lock detected (age: $([int]$lockAge)s), removing..."
                Remove-Item -Force $lockFile -ErrorAction SilentlyContinue
                continue
              }
            }

            if ($waitSeconds % 60 -eq 0) {
              Write-Host "Waiting for Unity ${{ inputs.unity-version }} lock... (${waitSeconds}s elapsed)"
            }
            Start-Sleep -Seconds 10
            $waitSeconds += 10
          }

          Write-Host "Lock acquired after ${waitSeconds}s"

      # =====================================================
      # Licensing Client 프로세스 정리 (다른 Unity 버전 충돌 방지)
      # 같은 머신에서 다른 Unity 버전의 Licensing Client가 실행 중이면
      # 프로토콜 버전 불일치(505)로 빌드가 실패합니다.
      # =====================================================
      - name: Cleanup Licensing Client (macOS)
        if: inputs.os == 'macos' && inputs.run-build && (inputs.test-level || '2') != '0'
        run: |
          CURRENT_VERSION="${{ steps.unity.outputs.UNITY_VERSION }}"
          echo "Current Unity version: ${CURRENT_VERSION}"
          echo "Checking for Licensing Client processes from other Unity versions..."

          KILLED=0
          while IFS= read -r line; do
            [ -z "$line" ] && continue
            PID=$(echo "$line" | awk '{print $1}')
            CMD=$(echo "$line" | awk '{$1=""; print $0}' | xargs)

            # 현재 버전의 Licensing Client는 유지
            if echo "$CMD" | grep -q "${CURRENT_VERSION}"; then
              echo "  Keeping (same version): PID=$PID"
              continue
            fi

            echo "  Killing (different version): PID=$PID CMD=$CMD"
            kill "$PID" 2>/dev/null || true
            KILLED=$((KILLED + 1))
          done < <(pgrep -af "Unity.Licensing.Client" 2>/dev/null || true)

          if [ $KILLED -gt 0 ]; then
            echo "::warning::Killed $KILLED Licensing Client process(es) from other Unity versions"
            sleep 2  # 프로세스 종료 대기
          else
            echo "No conflicting Licensing Client processes found"
          fi
          echo "Licensing Client cleanup complete"

      - name: Cleanup Licensing Client (Windows)
        if: inputs.os == 'windows' && inputs.run-build && (inputs.test-level || '2') != '0'
        shell: powershell
        run: |
          $currentVersion = "${{ steps.unity.outputs.UNITY_VERSION }}"
          Write-Host "Current Unity version: $currentVersion"
          Write-Host "Checking for Licensing Client processes from other Unity versions..."

          $killed = 0
          $processes = Get-Process -Name "Unity.Licensing.Client" -ErrorAction SilentlyContinue

          foreach ($proc in $processes) {
            $procPath = $proc.Path
            if (-not $procPath) { continue }

            # 현재 버전의 Licensing Client는 유지
            if ($procPath -match [regex]::Escape($currentVersion)) {
              Write-Host "  Keeping (same version): PID=$($proc.Id)"
              continue
            }

            Write-Host "  Killing (different version): PID=$($proc.Id) Path=$procPath"
            Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
            $killed++
          }

          if ($killed -gt 0) {
            Write-Host "::warning::Killed $killed Licensing Client process(es) from other Unity versions"
            Start-Sleep -Seconds 2  # 프로세스 종료 대기
          } else {
            Write-Host "No conflicting Licensing Client processes found"
          }
          Write-Host "Licensing Client cleanup complete"

      # =====================================================
      # Unity EditMode 유닛 테스트 (선택적)
      # =====================================================
      - name: Run Unity EditMode Tests (macOS)
        if: inputs.os == 'macos' && inputs.run-unit-test
        run: |
          UNITY_PATH="${{ steps.unity.outputs.UNITY_PATH }}"
          PROJECT_PATH="${{ github.workspace }}/Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}"
          LOG_FILE="/tmp/unity-test-${{ inputs.unity-version }}.log"
          RESULTS_FILE="/tmp/unity-test-results-${{ inputs.unity-version }}.xml"

          echo "Running Unity EditMode tests..."
          echo "Unity: ${UNITY_PATH}"
          echo "Project: ${PROJECT_PATH}"

          "$UNITY_PATH" -quit -batchmode -nographics \
            -projectPath "$PROJECT_PATH" \
            -runTests \
            -testPlatform EditMode \
            -testResults "$RESULTS_FILE" \
            -logFile - 2>&1 | tee "$LOG_FILE"
          EXIT_CODE=${PIPESTATUS[0]}

          echo "Unity Test Runner exited with code: $EXIT_CODE"

          if [ -f "$RESULTS_FILE" ]; then
            echo "=== Test Results ==="
            cat "$RESULTS_FILE"
          fi

          if [ $EXIT_CODE -ne 0 ]; then
            # 라이선스 오류는 무시하고 재시도하지 않음 (빌드 단계에서 처리)
            if grep -qE "No valid Unity Editor license found|Unsupported protocol version|ResponseCode: 505" "$LOG_FILE" 2>/dev/null; then
              echo "::warning::Unity license issue during tests, skipping test failure..."
            else
              echo "::error::Unity EditMode tests failed with exit code: $EXIT_CODE"
              exit $EXIT_CODE
            fi
          fi

          echo "Unity EditMode tests completed"

      - name: Run Unity EditMode Tests (Windows)
        if: inputs.os == 'windows' && inputs.run-unit-test
        shell: powershell
        run: |
          $unityPath = "${{ steps.unity.outputs.UNITY_PATH }}"
          $projectPath = "${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}"
          $logFile = "$env:TEMP\unity-test-${{ inputs.unity-version }}.log"
          $resultsFile = "$env:TEMP\unity-test-results-${{ inputs.unity-version }}.xml"

          Write-Host "Running Unity EditMode tests..."
          Write-Host "Unity: $unityPath"
          Write-Host "Project: $projectPath"

          $unityProcess = Start-Process -FilePath $unityPath -ArgumentList @(
            "-quit", "-batchmode", "-nographics",
            "-projectPath", $projectPath,
            "-runTests",
            "-testPlatform", "EditMode",
            "-testResults", $resultsFile,
            "-logFile", $logFile
          ) -PassThru -NoNewWindow

          Write-Host "Waiting for Unity tests to complete..."
          $lastSize = 0
          while (-not $unityProcess.HasExited) {
            Start-Sleep -Seconds 2
            if (Test-Path $logFile) {
              $content = Get-Content $logFile -Raw -ErrorAction SilentlyContinue
              if ($content -and $content.Length -gt $lastSize) {
                $newContent = $content.Substring($lastSize)
                Write-Host $newContent
                $lastSize = $content.Length
              }
            }
          }

          $unityProcess.WaitForExit()

          if (Test-Path $logFile) {
            $content = Get-Content $logFile -Raw -ErrorAction SilentlyContinue
            if ($content -and $content.Length -gt $lastSize) {
              Write-Host $content.Substring($lastSize)
            }
          }

          if (Test-Path $resultsFile) {
            Write-Host "=== Test Results ==="
            Get-Content $resultsFile
          }

          $exitCode = $unityProcess.ExitCode

          if ($null -eq $exitCode) {
            Write-Host "::warning::ExitCode is null, checking test results..."
            if (Test-Path $resultsFile) {
              $resultsContent = Get-Content $resultsFile -Raw
              if ($resultsContent -match 'result="Passed"') {
                Write-Host "Test results indicate pass"
                $exitCode = 0
              } else {
                Write-Host "::error::Test results indicate failure"
                $exitCode = 1
              }
            } else {
              $exitCode = 1
            }
          }

          Write-Host "Unity Test Runner exited with code: $exitCode"

          if ($exitCode -ne 0) {
            # 라이선스 오류 확인
            if (Test-Path $logFile) {
              $logContent = Get-Content $logFile -Raw -ErrorAction SilentlyContinue
              if ($logContent -match "No valid Unity Editor license found|Unsupported protocol version|ResponseCode: 505") {
                Write-Host "::warning::Unity license issue during tests, skipping test failure..."
                exit 0
              }
            }
            Write-Host "::error::Unity EditMode tests failed with exit code: $exitCode"
            exit $exitCode
          }

          Write-Host "Unity EditMode tests completed"

      - name: Upload Test Results
        if: inputs.run-unit-test && always()
        uses: actions/upload-artifact@v6
        with:
          name: unit-test-results-${{ inputs.os }}-${{ inputs.unity-version }}
          path: |
            /tmp/unity-test-results-${{ inputs.unity-version }}.xml
            ${{ runner.temp }}/unity-test-results-${{ inputs.unity-version }}.xml
          if-no-files-found: ignore
          retention-days: 7

      # =====================================================
      # Unity WebGL 빌드
      # =====================================================
      - name: Build Unity WebGL (macOS)
        if: inputs.os == 'macos' && inputs.run-build && (inputs.test-level || '2') != '0'
        uses: nick-invision/retry@v3
        env:
          AIT_DEBUG_CONSOLE: "true"
        with:
          timeout_minutes: 30
          max_attempts: 3
          retry_wait_seconds: 30
          shell: bash
          command: |
            UNITY_PATH="${{ steps.unity.outputs.UNITY_PATH }}"
            PROJECT_PATH="${{ github.workspace }}/Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}"
            LOG_FILE="/tmp/unity-build-${{ inputs.unity-version }}.log"

            echo "Unity Version: ${{ steps.unity.outputs.UNITY_VERSION }}"
            echo "Unity Path: ${UNITY_PATH}"
            echo "Project Path: ${PROJECT_PATH}"

            "$UNITY_PATH" -quit -batchmode -nographics \
              -projectPath "$PROJECT_PATH" \
              -executeMethod E2EBuildRunner.CommandLineBuild \
              -buildTarget WebGL \
              -logFile - 2>&1 | tee "$LOG_FILE"
            EXIT_CODE=${PIPESTATUS[0]}

            echo "Unity exited with code: $EXIT_CODE"

            if [ $EXIT_CODE -ne 0 ]; then
              # 라이선스 관련 오류 감지 (retry 액션이 자동 재시도)
              if grep -qE "No valid Unity Editor license found|Unsupported protocol version|ResponseCode: 505|LicensingClient has failed validation" "$LOG_FILE" 2>/dev/null; then
                echo "::warning::Unity license conflict detected, triggering retry..."
                exit 1
              fi
              if [ $EXIT_CODE -eq 199 ]; then
                echo "::warning::Unity license error (exit code 199), triggering retry..."
                exit 1
              fi
              echo "::error::Unity build failed with exit code: $EXIT_CODE"
              exit $EXIT_CODE
            fi

            echo "Unity build completed successfully (exit code: $EXIT_CODE)"

      - name: Build Unity WebGL (Windows)
        if: inputs.os == 'windows' && inputs.run-build && (inputs.test-level || '2') != '0'
        uses: nick-invision/retry@v3
        env:
          AIT_DEBUG_CONSOLE: "true"
        with:
          timeout_minutes: 30
          max_attempts: 3
          retry_wait_seconds: 30
          shell: powershell
          command: |
            $unityPath = "${{ steps.unity.outputs.UNITY_PATH }}"
            $projectPath = "${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}"

            Write-Host "Unity Version: ${{ steps.unity.outputs.UNITY_VERSION }}"
            Write-Host "Unity Path: $unityPath"
            Write-Host "Project Path: $projectPath"

            $logFile = "$env:TEMP\unity-build-${{ inputs.unity-version }}.log"
            Write-Host "Starting Unity build..."
            Write-Host "Log file: $logFile"

            $unityProcess = Start-Process -FilePath $unityPath -ArgumentList @(
              "-quit", "-batchmode", "-nographics",
              "-projectPath", $projectPath,
              "-executeMethod", "E2EBuildRunner.CommandLineBuild",
              "-buildTarget", "WebGL",
              "-logFile", $logFile
            ) -PassThru -NoNewWindow

            Write-Host "Waiting for Unity build to complete..."
            $logReader = $null
            while (-not $unityProcess.HasExited) {
              Start-Sleep -Seconds 5
              if (-not $logReader -and (Test-Path $logFile)) {
                $logReader = [System.IO.StreamReader]::new(
                  [System.IO.FileStream]::new($logFile, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::ReadWrite)
                )
              }
              if ($logReader) {
                $chunk = $logReader.ReadToEnd()
                if ($chunk) { Write-Host $chunk -NoNewline }
              }
            }

            # WaitForExit()으로 ExitCode 설정 보장 (HasExited 후에도 즉시 설정되지 않을 수 있음)
            $unityProcess.WaitForExit()

            # 남은 로그 읽기
            if ($logReader) {
              $chunk = $logReader.ReadToEnd()
              if ($chunk) { Write-Host $chunk -NoNewline }
              $logReader.Close()
            }

            $exitCode = $unityProcess.ExitCode
            Write-Host "Unity exited with code: $exitCode"

            # ExitCode가 null인 경우 방어 (빌드 출력 존재 여부로 판단)
            if ($null -eq $exitCode) {
              Write-Host "::warning::ExitCode is null, checking build output..."
              $distPath = "${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}\ait-build\dist"
              if (Test-Path $distPath) {
                Write-Host "Build output exists, treating as success"
                $exitCode = 0
              } else {
                Write-Host "::error::Build output missing and ExitCode null, treating as failure"
                $exitCode = 1
              }
            }

            if ($exitCode -ne 0) {
              # 라이선스 관련 오류 감지 (retry 액션이 자동 재시도)
              if (Test-Path $logFile) {
                $logContent = Get-Content $logFile -Raw -ErrorAction SilentlyContinue
                if ($logContent -match "No valid Unity Editor license found|Unsupported protocol version|ResponseCode: 505|LicensingClient has failed validation") {
                  Write-Host "::warning::Unity license conflict detected, triggering retry..."
                  exit 1
                }
              }
              if ($exitCode -eq 199) {
                Write-Host "::warning::Unity license error (exit code 199), triggering retry..."
                exit 1
              }
              Write-Host "::error::Unity build failed with exit code: $exitCode"
              exit $exitCode
            }

            Write-Host "Unity build completed successfully (exit code: $exitCode)"

      # =====================================================
      # Unity 빌드 락 해제
      # =====================================================
      - name: Release Unity Build Lock (macOS)
        if: always() && inputs.os == 'macos' && inputs.run-build && (inputs.test-level || '2') != '0' && steps.lock-macos.outputs.LOCK_DIR
        run: |
          LOCK_DIR="${{ steps.lock-macos.outputs.LOCK_DIR }}"
          if [ -d "${LOCK_DIR}" ]; then
            rmdir "${LOCK_DIR}" 2>/dev/null || rm -rf "${LOCK_DIR}"
            echo "Lock released: ${LOCK_DIR}"
          fi

      - name: Release Unity Build Lock (Windows)
        if: always() && inputs.os == 'windows' && inputs.run-build && (inputs.test-level || '2') != '0' && steps.lock-windows.outputs.LOCK_FILE
        shell: powershell
        run: |
          $lockFile = "${{ steps.lock-windows.outputs.LOCK_FILE }}"
          if (Test-Path $lockFile) {
            Remove-Item -Force $lockFile -ErrorAction SilentlyContinue
            Write-Host "Lock released: $lockFile"
          }

      # =====================================================
      # 빌드 출력 검증
      # =====================================================
      - name: Verify Build Output (macOS)
        if: inputs.os == 'macos' && inputs.run-build && (inputs.test-level || '2') != '0'
        run: |
          DIST_PATH="Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build/dist"
          AIT_BUILD_PATH="Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build"

          if [ ! -d "$DIST_PATH" ]; then
            echo "::error::Build output not found at $DIST_PATH"
            exit 1
          fi

          echo "dist/ folder verified"
          ls -la "$DIST_PATH"

          AIT_FILE=$(find "$DIST_PATH" -maxdepth 1 -name "*.ait" -type f 2>/dev/null | head -1)
          if [ -z "$AIT_FILE" ]; then
            AIT_FILE=$(find "$AIT_BUILD_PATH" -maxdepth 1 -name "*.ait" -type f 2>/dev/null | head -1)
          fi

          if [ -z "$AIT_FILE" ]; then
            echo "::error::.ait file not generated"
            ls -la "$AIT_BUILD_PATH"
            exit 1
          fi

          echo ".ait file verified: $AIT_FILE"

      - name: Verify Build Output (Windows)
        if: inputs.os == 'windows' && inputs.run-build && (inputs.test-level || '2') != '0'
        shell: cmd
        run: |
          @echo off
          setlocal enabledelayedexpansion
          set "DIST_PATH=Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}\ait-build\dist"
          set "AIT_BUILD_PATH=Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}\ait-build"

          if not exist "%DIST_PATH%" (
            echo ::error::Build output not found at %DIST_PATH%
            exit /b 1
          )

          echo dist\ folder verified
          dir "%DIST_PATH%"

          set "AIT_FILE="
          for %%f in ("%DIST_PATH%\*.ait") do (
            set "AIT_FILE=%%f"
            goto :found_ait
          )
          for %%f in ("%AIT_BUILD_PATH%\*.ait") do (
            set "AIT_FILE=%%f"
            goto :found_ait
          )

          echo ::error::.ait file not generated
          dir "%AIT_BUILD_PATH%"
          exit /b 1

          :found_ait
          echo .ait file verified: !AIT_FILE!

      # =====================================================
      # 아티팩트 업로드
      # =====================================================
      - name: Set Artifact Name
        id: artifact
        shell: bash
        run: |
          SDK_VERSION="${{ inputs.sdk-version }}"
          if [ -n "$SDK_VERSION" ]; then
            echo "name=ait-build-${{ inputs.os }}-${{ inputs.unity-version }}-v${SDK_VERSION}" >> $GITHUB_OUTPUT
          else
            echo "name=ait-build-${{ inputs.os }}-${{ inputs.unity-version }}" >> $GITHUB_OUTPUT
          fi

      - name: Upload AIT Build
        if: inputs.run-build && (inputs.test-level || '2') != '0'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ steps.artifact.outputs.name }}
          path: |
            Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build/dist/
            Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build/*.ait
            Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build/package.json
            Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build/pnpm-lock.yaml
            Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build/granite.config.ts
            Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}/ait-build/build-validation.json
          if-no-files-found: error
          retention-days: 7

      # =====================================================
      # E2E 테스트 (선택적)
      # =====================================================
      - name: Setup Node.js
        if: inputs.run-e2e-test && (inputs.test-level || '2') == '2'
        uses: actions/setup-node@v6
        with:
          node-version: 24

      - name: Install Playwright Dependencies (macOS)
        if: inputs.os == 'macos' && inputs.run-e2e-test && (inputs.test-level || '2') == '2'
        working-directory: Tests~/E2E/tests
        run: |
          # package.json 변경 시에만 node_modules 재설치 (self-hosted 캐시 활용)
          EXPECTED_HASH=$(shasum -a 256 package.json | cut -d' ' -f1)
          CACHED_HASH=""
          if [ -f node_modules/.package-hash ]; then
            CACHED_HASH=$(cat node_modules/.package-hash)
          fi

          if [ "$EXPECTED_HASH" != "$CACHED_HASH" ]; then
            echo "package.json changed, reinstalling dependencies..."
            rm -rf node_modules package-lock.json pnpm-lock.yaml
            pnpm install
            echo "$EXPECTED_HASH" > node_modules/.package-hash
          else
            echo "Dependencies up to date (cached)"
          fi

          # Playwright 브라우저 설치 (이미 설치된 버전이면 빠르게 스킵됨)
          pnpm exec playwright install chromium --with-deps
          pnpm exec playwright --version

      - name: Install Playwright Dependencies (Windows)
        if: inputs.os == 'windows' && inputs.run-e2e-test && (inputs.test-level || '2') == '2'
        working-directory: Tests~/E2E/tests
        shell: powershell
        env:
          # Use job-local Playwright cache to avoid race conditions between parallel runners
          PLAYWRIGHT_BROWSERS_PATH: ${{ github.workspace }}\.playwright-browsers
        run: |
          # package.json 변경 시에만 node_modules 재설치 (self-hosted 캐시 활용)
          $expectedHash = (Get-FileHash -Algorithm SHA256 package.json).Hash
          $cachedHash = ""
          if (Test-Path "node_modules\.package-hash") {
            $cachedHash = Get-Content "node_modules\.package-hash" -Raw
            $cachedHash = $cachedHash.Trim()
          }

          if ($expectedHash -ne $cachedHash) {
            Write-Host "package.json changed, reinstalling dependencies..."
            if (Test-Path node_modules) { Remove-Item -Recurse -Force node_modules }
            if (Test-Path package-lock.json) { Remove-Item -Force package-lock.json }
            if (Test-Path pnpm-lock.yaml) { Remove-Item -Force pnpm-lock.yaml }
            pnpm install
            Set-Content "node_modules\.package-hash" -Value $expectedHash -NoNewline
          } else {
            Write-Host "Dependencies up to date (cached)"
          }

          # Playwright 브라우저: 캐시 유지 (버전 변경 시에만 재설치)
          pnpm exec playwright install chromium --with-deps
          pnpm exec playwright --version

      - name: Run E2E Tests (macOS - Full)
        if: inputs.os == 'macos' && inputs.run-e2e-test && (inputs.test-level || '2') == '2'
        working-directory: Tests~/E2E/tests
        env:
          UNITY_PROJECT_PATH: ${{ github.workspace }}/Tests~/E2E/SampleUnityProject-${{ inputs.unity-version }}
          MOBILE_EMULATION: "true"
          TEST_LEVEL: ${{ inputs.test-level || '2' }}
        run: pnpm test

      - name: Run E2E Tests (Windows - Full)
        if: inputs.os == 'windows' && inputs.run-e2e-test && (inputs.test-level || '2') == '2'
        working-directory: Tests~/E2E/tests
        shell: powershell
        env:
          UNITY_PROJECT_PATH: ${{ github.workspace }}\Tests~\E2E\SampleUnityProject-${{ inputs.unity-version }}
          MOBILE_EMULATION: "true"
          TEST_LEVEL: ${{ inputs.test-level || '2' }}
          # Use job-local Playwright cache to avoid race conditions between parallel runners
          PLAYWRIGHT_BROWSERS_PATH: ${{ github.workspace }}\.playwright-browsers
        run: pnpm test

      # =====================================================
      # 벤치마크 결과 업로드 (선택적)
      # =====================================================
      - name: Upload Benchmark Results
        if: inputs.run-benchmark && (inputs.test-level || '2') == '2'
        uses: actions/upload-artifact@v6
        with:
          name: benchmark-results-${{ inputs.os }}-${{ inputs.unity-version }}
          path: Tests~/E2E/tests/benchmark-results.json
          if-no-files-found: ignore

      - name: Upload Playwright Report
        if: inputs.run-e2e-test && (inputs.test-level || '2') == '2' && always()
        uses: actions/upload-artifact@v6
        with:
          name: playwright-report-${{ inputs.os }}-${{ inputs.unity-version }}
          path: Tests~/E2E/tests/playwright-report/
          if-no-files-found: ignore
          compression-level: 9
          retention-days: 7
