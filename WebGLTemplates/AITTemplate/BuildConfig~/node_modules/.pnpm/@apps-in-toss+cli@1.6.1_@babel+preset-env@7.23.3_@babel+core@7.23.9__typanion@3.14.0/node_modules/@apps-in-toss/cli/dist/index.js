import { createRequire } from 'module'; const require = createRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../../.yarn/__virtual__/tsup-virtual-5fd798e2dc/0/cache/tsup-npm-8.3.5-ed25596739-7794953cbc.zip/node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../../.yarn/__virtual__/tsup-virtual-5fd798e2dc/0/cache/tsup-npm-8.3.5-ed25596739-7794953cbc.zip/node_modules/tsup/assets/esm_shims.js"() {
    "use strict";
  }
});

// ../../../.yarn/cache/ms-npm-2.1.3-eae95409bd-d924b57e73.zip/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../../.yarn/cache/ms-npm-2.1.3-eae95409bd-d924b57e73.zip/node_modules/ms/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/common.js"(exports, module) {
    "use strict";
    init_esm_shims();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug6(...args) {
          if (!debug6.enabled) {
            return;
          }
          const self = debug6;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug6.namespace = namespace;
        debug6.useColors = createDebug.useColors();
        debug6.color = createDebug.selectColor(namespace);
        debug6.extend = extend;
        debug6.destroy = createDebug.destroy;
        Object.defineProperty(debug6, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug6);
        }
        return debug6;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/browser.js"(exports, module) {
    "use strict";
    init_esm_shims();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/node.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init;
    exports.log = log4;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = __require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log4(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug6) {
      debug6.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug6.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../../.yarn/__virtual__/debug-virtual-5f733de965/0/cache/debug-npm-4.4.0-f1ca372596-db94f1a182.zip/node_modules/debug/src/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// ../../../.yarn/cache/picocolors-npm-1.1.1-b0c45fa35e-e2e3e8170a.zip/node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "../../../.yarn/cache/picocolors-npm-1.1.1-b0c45fa35e-e2e3e8170a.zip/node_modules/picocolors/picocolors.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var p5 = process || {};
    var argv = p5.argv || [];
    var env = p5.env || {};
    var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p5.platform === "win32" || (p5.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
    var formatter = (open, close, replace = open) => (input) => {
      let string = "" + input, index = string.indexOf(close, open.length);
      return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
    var replaceClose = (string, close, replace, index) => {
      let result = "", cursor = 0;
      do {
        result += string.substring(cursor, index) + replace;
        cursor = index + close.length;
        index = string.indexOf(close, cursor);
      } while (~index);
      return result + string.substring(cursor);
    };
    var createColors = (enabled = isColorSupported) => {
      let f = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module.exports = createColors();
    module.exports.createColors = createColors;
  }
});

// src/index.ts
init_esm_shims();
import { Cli, Builtins } from "clipanion";

// src/DeployCommand.ts
init_esm_shims();
var import_debug3 = __toESM(require_src(), 1);
var import_picocolors = __toESM(require_picocolors(), 1);
import assert from "assert";
import fs3 from "fs";
import path2 from "path";
import * as p from "@clack/prompts";
import { getPackageRoot, readZipContent } from "@granite-js/utils";
import { Command, Option } from "clipanion";

// src/utils/TokenStorage.ts
init_esm_shims();
import fs from "fs";
import os from "os";
import path from "path";
var TokenStorage = class {
  static get path() {
    const home = os.homedir();
    const dir = path.join(home, ".ait");
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    return path.join(dir, "credentials");
  }
  static read() {
    const file = this.path;
    if (!fs.existsSync(file)) {
      return {};
    }
    const raw = fs.readFileSync(file, "utf8");
    try {
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") {
        return parsed;
      }
    } catch {
    }
    return {};
  }
  static write(map) {
    const file = this.path;
    const content = JSON.stringify(map, null, 2);
    fs.writeFileSync(file, content, { encoding: "utf8" });
  }
  static set(workspace, token) {
    const creds = this.read();
    creds[workspace] = token;
    this.write(creds);
  }
  static delete(workspace) {
    const creds = this.read();
    if (workspace in creds) {
      delete creds[workspace];
      this.write(creds);
      return true;
    }
    return false;
  }
  static get(workspace) {
    const creds = this.read();
    return creds[workspace];
  }
};

// src/utils/constants.ts
init_esm_shims();
var APP_MANIFEST_NAME = "app.json";
var DEFAULT_API_BASE_URL = "https://apps-in-toss.toss.im/console";

// src/utils/upload.ts
init_esm_shims();
var import_debug2 = __toESM(require_src(), 1);
import fs2 from "fs";

// src/utils/flowAsync.ts
init_esm_shims();
function flowAsync(...funcs) {
  return async function(...args) {
    let result = funcs.length ? await funcs[0].apply(this, args) : args[0];
    for (let i = 1; i < funcs.length; i++) {
      result = await funcs[i]?.call(this, result);
    }
    return result;
  };
}

// src/utils/handleFetchResponse.ts
init_esm_shims();
var import_debug = __toESM(require_src(), 1);
var debug = (0, import_debug.default)("api");
async function handleFetchResponse(response) {
  debug(`Response ${response.status} ${response.statusText}`);
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  const data = await response.clone().json();
  debug("response", data);
  if (data.resultType !== "SUCCESS") {
    const errorCode = data?.error?.errorCode ?? "-1";
    const errorReason = data?.error?.reason ?? "unknown";
    throw new Error(`${errorReason} (Code: ${errorCode})`);
  }
  return data.success;
}

// src/utils/withRetry.ts
init_esm_shims();
import { setTimeout as sleep } from "node:timers/promises";
async function withRetry(fn, options = {}) {
  const { maxRetries = 60, delayMs = 1e4, shouldRetryOnResult, shouldRetryOnError, onRetry } = options;
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      const result = await fn();
      if (shouldRetryOnResult && shouldRetryOnResult(result)) {
        onRetry?.(attempt + 1, { result });
        await sleep(delayMs);
        attempt++;
        continue;
      }
      return result;
    } catch (error) {
      const retryable = shouldRetryOnError ? shouldRetryOnError(error) : false;
      if (!retryable) {
        throw error;
      }
      onRetry?.(attempt + 1, { error });
      await sleep(delayMs);
      attempt++;
    }
  }
  throw new Error("\uCD5C\uB300 \uB300\uAE30\uC2DC\uAC04\uC744 \uCD08\uACFC\uD588\uC5B4\uC694.");
}

// src/utils/upload.ts
var debug2 = (0, import_debug2.default)("cli:deploy");
async function uploadArtifact(config) {
  debug2("uploadArtifact", config);
  return flowAsync(uploadStart(), uploadArtifactToRemote(), uploadComplete(), checkBundleStatus())(config);
}
function uploadStart() {
  return async (config) => {
    debug2("uploadStart", config);
    const baseUrl = config.baseUrl ?? DEFAULT_API_BASE_URL;
    const response = await fetch(`${baseUrl}/api-public/v3/openapi/bundles/${config.appName}/upload-start`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${config.apiKey}`
      },
      body: JSON.stringify({
        deploymentId: config.deploymentId
      })
    });
    return {
      config,
      output: await handleFetchResponse(response)
    };
  };
}
function uploadArtifactToRemote() {
  return async (params) => {
    const { config, output } = params;
    debug2("uploadArtifactToRemote", config, output);
    const stat = await fs2.promises.stat(config.artifactPath);
    const stream = fs2.createReadStream(config.artifactPath);
    const response = await fetch(output.uploadUrl, {
      method: "PUT",
      headers: {
        "Content-Type": "application/zip",
        "Content-Length": String(stat.size)
      },
      body: stream,
      duplex: "half"
    });
    if (!response.ok) {
      throw new Error("\uC5C5\uB85C\uB4DC\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. \uB2E4\uC2DC \uC2DC\uB3C4\uD574\uC8FC\uC138\uC694.");
    }
    return config;
  };
}
function uploadComplete() {
  return async (config) => {
    debug2("uploadComplete", config);
    const baseUrl = config.baseUrl ?? DEFAULT_API_BASE_URL;
    const response = await fetch(`${baseUrl}/api-public/v3/openapi/bundles/${config.appName}/upload-complete`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${config.apiKey}`
      },
      body: JSON.stringify({
        deploymentId: config.deploymentId
      })
    });
    await handleFetchResponse(response);
    return config;
  };
}
function checkBundleStatus(delayMs = 1e4, maxRetries = 10) {
  return async (config) => {
    const baseUrl = config.baseUrl ?? DEFAULT_API_BASE_URL;
    function assertBuildNotFailed(config2, reviewStatus2) {
      if (reviewStatus2 === "BUILD_FAILED") {
        throw new Error(
          `\uBE4C\uB4DC\uC5D0 \uC2E4\uD328\uD588\uC2B5\uB2C8\uB2E4. \uCF58\uC194\uC5D0\uC11C \uBE4C\uB4DC \uC2E4\uD328 \uC0AC\uC720\uB97C \uD655\uC778\uD574\uC8FC\uC138\uC694.(deploymentId: ${config2.deploymentId})`
        );
      }
    }
    async function pollBundleStatus() {
      const response = await fetch(
        `${baseUrl}/api-public/v3/openapi/bundles/${config.appName}/deployments/${config.deploymentId}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${config.apiKey}`
          }
        }
      );
      const { reviewStatus: reviewStatus2 } = await handleFetchResponse(response);
      return reviewStatus2;
    }
    const reviewStatus = await withRetry(pollBundleStatus, {
      maxRetries,
      delayMs,
      shouldRetryOnResult: (reviewStatus2) => reviewStatus2 === "BUILDING" || reviewStatus2 === "PREPARE",
      shouldRetryOnError: () => false,
      onRetry: (attempt, info) => debug2("checkBundleStatus: retry", { attempt, ...info })
    });
    assertBuildNotFailed(config, reviewStatus);
  };
}

// src/DeployCommand.ts
var debug3 = (0, import_debug3.default)("cli:deploy");
var DeployCommand = class extends Command {
  static paths = [["deploy"]];
  apiKey = Option.String("--api-key", {
    required: false,
    description: "\uC54C\uD30C \uBC30\uD3EC\uB97C \uC704\uD55C API \uD0A4"
  });
  workspace = Option.String("--workspace", {
    required: false,
    description: "\uD1A0\uD070 \uC6CC\uD06C\uC2A4\uD398\uC774\uC2A4 \uC774\uB984"
  });
  baseUrl = Option.String("--base-url", {
    description: "API Base URL"
  });
  async execute() {
    const baseUrl = this.baseUrl;
    const workspace = this.workspace || "default";
    const apiKey = await this.getApiKey(workspace);
    if (p.isCancel(apiKey)) {
      return;
    }
    try {
      const packageRoot = getPackageRoot();
      const artifactFile = fs3.readdirSync(packageRoot).find((file) => file.endsWith(".ait"));
      if (!artifactFile) {
        throw new Error("\uBC30\uD3EC\uD560 .ait \uD30C\uC77C\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      }
      const resolvedArtifactPath = path2.resolve(packageRoot, artifactFile);
      const { appName, deploymentId } = await readZipContent(resolvedArtifactPath, APP_MANIFEST_NAME).then((rawAppManifest) => {
        const appManifest = JSON.parse(rawAppManifest);
        const appName2 = appManifest.appName;
        const deploymentId2 = appManifest._metadata.deploymentId;
        assert(typeof appName2 === "string", "invalid appName");
        assert(typeof deploymentId2 === "string", "invalid deploymentId");
        return { appName: appName2, deploymentId: deploymentId2 };
      }).catch((error) => {
        debug3("invalid ait file", error);
        throw new Error("\uC720\uD6A8\uD558\uC9C0 \uC54A\uC740 ait \uD30C\uC77C\uC785\uB2C8\uB2E4");
      });
      const colorAppName = import_picocolors.default.underline(import_picocolors.default.cyan(appName));
      await p.tasks([
        {
          title: `${colorAppName} \uC571 \uBC30\uD3EC \uC911...`,
          task: async () => {
            await uploadArtifact({
              artifactPath: resolvedArtifactPath,
              appName,
              deploymentId,
              apiKey,
              baseUrl
            });
            return `${colorAppName} \uBC30\uD3EC\uAC00 \uC644\uB8CC\uB418\uC5C8\uC5B4\uC694`;
          }
        }
      ]);
      p.note(import_picocolors.default.underline(import_picocolors.default.green(`intoss-private://${appName}?_deploymentId=${deploymentId}`)));
    } catch (error) {
      if (error instanceof Error) {
        p.log.error(error.message);
      } else {
        console.error(error);
      }
      process.exit(1);
    }
  }
  async getApiKey(workspace) {
    const token = TokenStorage.get(workspace) || this.apiKey;
    if (token) {
      return token;
    }
    return await p.password({
      message: "\uC571\uC778\uD1A0\uC2A4 \uBC30\uD3EC API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694",
      validate: (value) => {
        if (value.length === 0) {
          return "API \uD0A4\uB294 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.";
        }
        return;
      }
    });
  }
};

// src/InitCommand.ts
init_esm_shims();
import fs4 from "fs";
import path3 from "path";
import * as p2 from "@clack/prompts";
import { getPackageRoot as getPackageRoot2 } from "@granite-js/utils";
import { Command as Command2, Option as Option2 } from "clipanion";

// ../../../.yarn/cache/es-toolkit-npm-1.32.0-019fc7c155-56ba965570.zip/node_modules/es-toolkit/dist/index.mjs
init_esm_shims();

// ../../../.yarn/cache/es-toolkit-npm-1.32.0-019fc7c155-56ba965570.zip/node_modules/es-toolkit/dist/string/words.mjs
init_esm_shims();
var CASE_SPLIT_PATTERN = /\p{Lu}?\p{Ll}+|[0-9]+|\p{Lu}+(?!\p{Ll})|\p{Emoji_Presentation}|\p{Extended_Pictographic}|\p{L}+/gu;
function words(str) {
  return Array.from(str.match(CASE_SPLIT_PATTERN) ?? []);
}

// ../../../.yarn/cache/es-toolkit-npm-1.32.0-019fc7c155-56ba965570.zip/node_modules/es-toolkit/dist/string/kebabCase.mjs
init_esm_shims();
function kebabCase(str) {
  const words$1 = words(str);
  return words$1.map((word) => word.toLowerCase()).join("-");
}

// src/templates.ts
init_esm_shims();
var WEB_FRAMEWORK_CONFIG_TEMPLATE = `import { defineConfig } from '@apps-in-toss/web-framework/config';

export default defineConfig({
  appName: '%%appName%%',
  brand: {
    displayName: '%%appName%%', // \uD654\uBA74\uC5D0 \uB178\uCD9C\uB420 \uC571\uC758 \uD55C\uAE00 \uC774\uB984\uC73C\uB85C \uBC14\uAFD4\uC8FC\uC138\uC694.
    primaryColor: '#3182F6', // \uD654\uBA74\uC5D0 \uB178\uCD9C\uB420 \uC571\uC758 \uAE30\uBCF8 \uC0C9\uC0C1\uC73C\uB85C \uBC14\uAFD4\uC8FC\uC138\uC694.
    icon: null, // \uD654\uBA74\uC5D0 \uB178\uCD9C\uB420 \uC571\uC758 \uC544\uC774\uCF58 \uC774\uBBF8\uC9C0 \uC8FC\uC18C\uB85C \uBC14\uAFD4\uC8FC\uC138\uC694.
    bridgeColorMode: 'basic',
  },
  web: {
    host: 'localhost',
    port: %%webPort%%,
    commands: {
      dev: '%%webDevCommand%%',
      build: '%%webBuildCommand%%',
    },
  },
  permissions: [],
  outdir: 'dist',
});
`;
var REACT_NATIVE_FRAMEWORK_CONFIG_TEMPLATE = `import { appsInToss } from '@apps-in-toss/framework/plugins';
import { defineConfig } from '@granite-js/react-native/config';

export default defineConfig({
  scheme: 'intoss',
  appName: '%%appName%%',
  plugins: [
    appsInToss({
      brand: {
        displayName: '%%appName%%', // \uD654\uBA74\uC5D0 \uB178\uCD9C\uB420 \uC571\uC758 \uD55C\uAE00 \uC774\uB984\uC73C\uB85C \uBC14\uAFD4\uC8FC\uC138\uC694.
        primaryColor: '#3182F6', // \uD654\uBA74\uC5D0 \uB178\uCD9C\uB420 \uC571\uC758 \uAE30\uBCF8 \uC0C9\uC0C1\uC73C\uB85C \uBC14\uAFD4\uC8FC\uC138\uC694.
        icon: null, // \uD654\uBA74\uC5D0 \uB178\uCD9C\uB420 \uC571\uC758 \uC544\uC774\uCF58 \uC774\uBBF8\uC9C0 \uC8FC\uC18C\uB85C \uBC14\uAFD4\uC8FC\uC138\uC694.
        bridgeColorMode: 'basic',
      },
      permissions: [],
    }),
  ],
});
`;
var APP_TEMPLATE = `import { AppsInToss } from '@apps-in-toss/framework';
import { PropsWithChildren } from 'react';
import { InitialProps } from '@granite-js/react-native';
import { context } from '../require.context';

function AppContainer({ children }: PropsWithChildren<InitialProps>) {
  return <>{children}</>;
}

export default AppsInToss.registerApp(AppContainer, { context });
`;

// src/utils/ensureSelect.ts
init_esm_shims();
async function ensureSelect({
  value,
  prompt
}) {
  if (value) {
    return value;
  }
  return await prompt();
}

// src/utils/transformTemplate.ts
init_esm_shims();
function transformTemplate(templateString, values) {
  let result = templateString;
  for (const key in values) {
    const placeholder = `%%${key}%%`;
    result = result.replace(new RegExp(placeholder, "g"), values[key]);
  }
  return result;
}

// src/InitCommand.ts
async function templateWebFramework({ appName, cwd, skipInput }) {
  const packageJson = await fs4.promises.readFile(path3.join(cwd, "package.json"), {
    encoding: "utf-8"
  });
  const scripts = JSON.parse(packageJson);
  const originalScripts = {
    dev: scripts?.scripts?.dev || scripts?.scripts?.start,
    build: scripts?.scripts?.build
  };
  scripts.scripts.dev = "granite dev";
  scripts.scripts.build = "granite build";
  scripts.scripts.deploy = "ait deploy";
  await fs4.promises.writeFile(path3.join(cwd, "package.json"), JSON.stringify(scripts, null, 2), {
    encoding: "utf-8"
  });
  p2.log.step(".gitignore \uD30C\uC77C\uC744 \uC5C5\uB370\uC774\uD2B8\uD558\uB294 \uC911...");
  await fs4.promises.appendFile(path3.join(cwd, ".gitignore"), "\n.granite\n");
  const placeholder = {
    dev: originalScripts.dev === "granite dev" ? "" : originalScripts.dev,
    build: originalScripts.build === "granite build" ? "" : originalScripts.build
  };
  const scriptInputs = skipInput ? placeholder : await p2.group(
    {
      dev: () => p2.text({
        message: "\uC6F9 \uBC88\uB4E4\uB7EC\uC758 dev \uBA85\uB839\uC5B4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
        defaultValue: placeholder.dev,
        placeholder: placeholder.dev
      }),
      build: () => p2.text({
        message: "\uC6F9 \uBC88\uB4E4\uB7EC\uC758 build \uBA85\uB839\uC5B4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694.",
        defaultValue: placeholder.build,
        placeholder: placeholder.build
      })
    },
    {
      onCancel: () => {
        p2.cancel("\uCD08\uAE30\uD654\uAC00 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4");
      }
    }
  );
  p2.log.step("granite.config.ts \uD30C\uC77C\uC744 \uC0DD\uC131\uD558\uB294 \uC911...");
  const webPort = skipInput ? "5173" : await p2.text({
    message: "Enter web port",
    placeholder: "5173",
    defaultValue: "5173"
  });
  if (p2.isCancel(webPort)) {
    p2.cancel("\uCD08\uAE30\uD654\uAC00 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4");
    return;
  }
  const config = transformTemplate(WEB_FRAMEWORK_CONFIG_TEMPLATE, {
    appName,
    webPort,
    webDevCommand: scriptInputs.dev === "granite dev" ? "" : scriptInputs.dev,
    webBuildCommand: scriptInputs.build === "granite build" ? "" : scriptInputs.build
  });
  await fs4.promises.writeFile(path3.join(cwd, "granite.config.ts"), config, {
    encoding: "utf-8"
  });
}
async function templateReactNative({ appName, cwd }) {
  p2.log.step("granite.config.ts \uD30C\uC77C\uC744 \uC0DD\uC131\uD558\uB294 \uC911...");
  const config = transformTemplate(REACT_NATIVE_FRAMEWORK_CONFIG_TEMPLATE, {
    appName
  });
  await fs4.promises.writeFile(path3.join(cwd, "granite.config.ts"), config, {
    encoding: "utf-8"
  });
  p2.log.step("src/_app.tsx \uD30C\uC77C\uC744 \uC0DD\uC131\uD558\uB294 \uC911...");
  await fs4.promises.writeFile(path3.join(cwd, "src", "_app.tsx"), APP_TEMPLATE, {
    encoding: "utf-8"
  });
}
var InitCommand = class extends Command2 {
  static paths = [[`init`]];
  template = Option2.String("--template", { required: false });
  appName = Option2.String("--app-name", { required: false });
  skipInput = Option2.Boolean("--skip-input", { required: false, hidden: true });
  async execute() {
    const template = await ensureSelect({
      value: this.template,
      prompt: async () => p2.select({
        message: "\uD504\uB85C\uC81D\uD2B8\uB97C \uCD08\uAE30\uD654\uD560 \uD15C\uD50C\uB9BF\uC744 \uC120\uD0DD\uD574\uC8FC\uC138\uC694.",
        options: [
          {
            value: "web-framework",
            label: "\uC6F9 \uD504\uB808\uC784\uC6CC\uD06C",
            hint: "\uC6F9 \uD504\uB85C\uC81D\uD2B8\uC5D0 \uC571\uC778\uD1A0\uC2A4 \uC6F9\uBDF0 \uAC1C\uBC1C\uD658\uACBD\uC744 \uC138\uD305\uD569\uB2C8\uB2E4."
          },
          {
            value: "react-native",
            label: "React Native \uD504\uB808\uC784\uC6CC\uD06C (Granite)",
            hint: "Granite \uD504\uB85C\uC81D\uD2B8\uC5D0 \uC571\uC778\uD1A0\uC2A4 React Native\uC6A9 \uAC1C\uBC1C\uD658\uACBD\uC744 \uC138\uD305\uD569\uB2C8\uB2E4."
          }
        ]
      })
    });
    if (p2.isCancel(template)) {
      process.exit(0);
    }
    const cwd = getPackageRoot2();
    p2.intro("\u{1F680} \uC571 \uCD08\uAE30\uD654\uB97C \uC2DC\uC791\uD569\uB2C8\uB2E4");
    const appName = await ensureSelect({
      value: this.appName,
      prompt: async () => p2.text({
        message: "Enter app name",
        validate: (value) => {
          if (!value) {
            return "\uC571 \uC774\uB984\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694";
          }
          const kebabCaseValue = kebabCase(value);
          if (value !== kebabCaseValue) {
            return `\uC571 \uC774\uB984\uC740 \uCF00\uBC25-\uCF00\uC774\uC2A4 \uD615\uC2DD\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4 (\uC608\uC2DC: ${kebabCaseValue})`;
          }
          return;
        }
      })
    });
    if (p2.isCancel(appName)) {
      p2.cancel("\uCD08\uAE30\uD654\uAC00 \uCDE8\uC18C\uB418\uC5C8\uC2B5\uB2C8\uB2E4");
      return;
    }
    p2.log.step(`\uC571 \uC774\uB984\uC774 '${appName}'\uC73C\uB85C \uC124\uC815\uB418\uC5C8\uC2B5\uB2C8\uB2E4`);
    switch (template) {
      case "web-framework": {
        await templateWebFramework({
          appName,
          cwd,
          skipInput: this.skipInput ?? false
        });
        break;
      }
      case "react-native": {
        await templateReactNative({
          appName,
          cwd
        });
        break;
      }
    }
    p2.outro("\u2728 \uCD08\uAE30\uD654\uAC00 \uC644\uB8CC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!");
  }
};

// src/MigrateCommand/index.ts
init_esm_shims();

// src/MigrateCommand/MigrateCommand.ts
init_esm_shims();
import { Command as Command3, Option as Option3 } from "clipanion";

// src/MigrateCommand/logger/index.ts
init_esm_shims();
var import_picocolors2 = __toESM(require_picocolors(), 1);
var Logger = class {
  prefix = import_picocolors2.default.bold(import_picocolors2.default.bgCyan(import_picocolors2.default.black(" MIGRATE ")));
  log(...args) {
    console.log(this.prefix, ...args);
  }
  success(...args) {
    console.log(this.prefix, import_picocolors2.default.green("\u2713"), ...args);
  }
  error(...args) {
    console.error(this.prefix, import_picocolors2.default.red("\u2717"), ...args);
  }
  warn(...args) {
    console.warn(this.prefix, import_picocolors2.default.yellow("!"), ...args);
  }
};
var logger = new Logger();

// src/MigrateCommand/presets/index.ts
init_esm_shims();

// src/MigrateCommand/presets/granite/index.ts
init_esm_shims();

// src/MigrateCommand/presets/granite/migrateGranite.ts
init_esm_shims();
import assert2 from "assert";
import dedent from "dedent";

// src/MigrateCommand/presets/granite/configProcessor.ts
init_esm_shims();

// src/MigrateCommand/fs/fileProcessor.ts
init_esm_shims();
import { promises as fs5 } from "fs";
async function readFile(filePath) {
  try {
    return await fs5.readFile(filePath, "utf-8");
  } catch {
    throw new Error(`Failed to read file: ${filePath}`);
  }
}
async function writeFile(filePath, content) {
  try {
    await fs5.writeFile(filePath, content, "utf-8");
  } catch {
    throw new Error(`Failed to write file: ${filePath}`);
  }
}
async function fileExists(filePath) {
  try {
    await fs5.access(filePath);
    return true;
  } catch {
    return false;
  }
}
async function renameFile(oldPath, newPath) {
  try {
    await fs5.rename(oldPath, newPath);
  } catch {
    throw new Error(`Failed to rename file: ${oldPath} -> ${newPath}`);
  }
}

// src/MigrateCommand/presets/granite/configProcessor.ts
var configTransformer = (root, { j }) => {
  root.find(j.ImportDeclaration).forEach((path6) => {
    const source = path6.value.source;
    if (j.StringLiteral.check(source) && source.value === "react-native-bedrock/config") {
      const defineConfigName = path6.value.specifiers?.find(
        (specifier) => j.ImportSpecifier.check(specifier) && specifier.imported.name === "defineConfig"
      )?.local?.name;
      if (!defineConfigName) {
        return;
      }
      root.find(j.CallExpression).forEach((path7) => {
        const callee = path7.value.callee;
        if (j.Identifier.check(callee) && callee.name === defineConfigName && path7.value.arguments.length > 0 && j.ObjectExpression.check(path7.value.arguments[0])) {
          const obj = path7.value.arguments[0];
          const hasScheme = obj.properties.some(
            (prop) => j.ObjectProperty.check(prop) && j.Identifier.check(prop.key) && prop.key.name === "scheme"
          );
          if (!hasScheme) {
            obj.properties.unshift(j.objectProperty(j.identifier("scheme"), j.stringLiteral("intoss")));
          }
          const routerImport = root.find(j.ImportDeclaration).filter((path8) => {
            const source2 = path8.value.source;
            return j.StringLiteral.check(source2) && source2.value === "@granite-js/plugin-router";
          });
          if (routerImport.length === 0) {
            const firstImport = root.find(j.ImportDeclaration).at(0);
            if (firstImport.length > 0) {
              firstImport.insertAfter(
                j.importDeclaration(
                  [j.importSpecifier(j.identifier("router"))],
                  j.stringLiteral("@granite-js/plugin-router")
                )
              );
            }
          }
          const hasPlugins = obj.properties.some(
            (prop) => j.ObjectProperty.check(prop) && j.Identifier.check(prop.key) && prop.key.name === "plugins"
          );
          const routerPluginCallExpr = j.callExpression(j.identifier("router"), []);
          if (hasPlugins) {
            const pluginsProp = obj.properties.find(
              (prop) => j.ObjectProperty.check(prop) && j.Identifier.check(prop.key) && prop.key.name === "plugins"
            );
            if (j.ObjectProperty.check(pluginsProp) && j.ArrayExpression.check(pluginsProp.value)) {
              const hasRouter = pluginsProp.value.elements.some(
                (element) => j.Identifier.check(element) && element.name === "router"
              );
              if (!hasRouter) {
                pluginsProp.value.elements.push(routerPluginCallExpr);
              }
            }
          } else {
            obj.properties.unshift(
              j.objectProperty(j.identifier("plugins"), j.arrayExpression([routerPluginCallExpr]))
            );
          }
        }
      });
    }
  });
  return root;
};
var processBedrockConfig = async (cwd, config) => {
  logger.log("Processing bedrock.config.ts...");
  const bedrockConfigPath = `${cwd}/bedrock.config.ts`;
  const graniteConfigPath = `${cwd}/granite.config.ts`;
  if (!await fileExists(bedrockConfigPath)) {
    logger.log("No bedrock.config.ts found");
    return;
  }
  if (config.dryRun) {
    return;
  }
  try {
    await renameFile(bedrockConfigPath, graniteConfigPath);
    logger.success("Renamed bedrock.config.ts to granite.config.ts");
  } catch (error) {
    logger.error(`Failed to process bedrock.config.ts: ${error}`);
  }
};

// src/MigrateCommand/presets/granite/gitignoreProcessor.ts
init_esm_shims();
var processGitignore = async (cwd, config) => {
  let modified = false;
  logger.log("Processing .gitignore...");
  const gitignorePath = `${cwd}/.gitignore`;
  try {
    if (await fileExists(gitignorePath)) {
      const content = await readFile(gitignorePath);
      const newContent = content.replace(/\.bedrock/g, ".granite");
      if (newContent !== content) {
        if (config.dryRun) {
          logger.log("Skipping file write in dry run mode");
        } else {
          await writeFile(gitignorePath, newContent);
          logger.success("Updated .gitignore");
        }
        modified ||= true;
      } else {
        logger.log(`No changes needed in ${gitignorePath}`);
      }
    }
  } catch (error) {
    logger.error(`Failed to process .gitignore: ${error}`);
  }
  if (!modified) {
    logger.log("No .gitignore found");
    return;
  }
};

// src/MigrateCommand/presets/granite/identifierReplacements.ts
init_esm_shims();

// src/MigrateCommand/codemod/utils.ts
init_esm_shims();
function getIdentifierName(j, id) {
  if (typeof id === "string") {
    return id;
  }
  if (j.Identifier.check(id)) {
    return id.name;
  }
  return "";
}

// src/MigrateCommand/presets/granite/identifierReplacements.ts
var identifierReplacementsTransformer = (root, { j }) => {
  const importedVariables = /* @__PURE__ */ new Set();
  function toGraniteName(name) {
    let newName = null;
    if (name === "BedrockRoute") {
      newName = "createRoute";
    } else if (name.startsWith("bedrock")) {
      newName = toGraniteCamel(name);
    } else if (name.startsWith("Bedrock")) {
      newName = toGranitePascal(name);
    } else if (name.startsWith("BEDROCK")) {
      newName = toGraniteSnake(name);
    }
    return newName;
  }
  function toGraniteCamel(name) {
    const rest = name.substring(7);
    return "granite" + rest;
  }
  function toGranitePascal(name) {
    const rest = name.substring(7);
    return "Granite" + rest;
  }
  function toGraniteSnake(name) {
    const rest = name.substring(7);
    return "GRANITE" + rest;
  }
  root.find(j.ImportDeclaration, { source: { value: "react-native-bedrock" } }).forEach((importPath) => {
    importPath.value.specifiers?.forEach((specifier) => {
      if (j.ImportSpecifier.check(specifier)) {
        const importedName = getIdentifierName(j, specifier.imported);
        const localName = specifier.local ? getIdentifierName(j, specifier.local) : importedName;
        if (j.Identifier.check(specifier.imported)) {
          const newName = toGraniteName(importedName);
          if (newName) {
            specifier.imported.name = newName;
          }
        }
        importedVariables.add(localName);
      }
    });
  });
  root.find(j.Identifier).forEach((path6) => {
    const name = path6.value.name;
    if (importedVariables.has(name)) {
      const newName = toGraniteName(path6.value.name);
      if (newName) {
        path6.value.name = newName;
      }
    }
  });
  return root;
};

// src/MigrateCommand/presets/granite/isBedrockProject.ts
init_esm_shims();
import * as fs6 from "fs";
var BASE_NAME = "bedrock.config";
var EXTENSIONS = ["ts", "mts", "js", "cjs"];
async function isBedrockProject(cwd) {
  const files = fs6.readdirSync(cwd);
  return files.some(isBedrockConfigFile);
}
function isBedrockConfigFile(file) {
  return EXTENSIONS.some((ext) => file === `${BASE_NAME}.${ext}`);
}

// src/MigrateCommand/presets/granite/packageImports.ts
init_esm_shims();
var import_picocolors3 = __toESM(require_picocolors(), 1);

// src/MigrateCommand/presets/granite/constants.ts
init_esm_shims();
var UNSUPPORTED_LIBRARIES = [
  "@react-native-bedrock/e2e-testing-library",
  "@react-native-bedrock/babel-plugin-obfuscate"
];
var TARGET_VERSION = {
  granitePackages: "0.1.21",
  appsInTossPackages: "^1.0.0",
  tossDesignSystem: "^1.0.4"
};

// src/MigrateCommand/presets/granite/packageImports.ts
var packageImportsTransformer = (root, { j }, { fileName = "<unknown>" }) => {
  function transformPackageName(value) {
    if (UNSUPPORTED_LIBRARIES.includes(value)) {
      const libName = import_picocolors3.default.gray(`(${value})`);
      logger.warn(`Unsupported library found ${libName}`);
      logger.warn(`\u2514\u2500 ${import_picocolors3.default.gray(`at ${fileName}`)}`);
      return value;
    }
    if (value === "react-native-bedrock" || value.startsWith("react-native-bedrock/")) {
      return value.replace("react-native-bedrock", "@granite-js/react-native");
    }
    if (value.startsWith("@react-native-bedrock/")) {
      return value.replace("@react-native-bedrock/", "@granite-js/");
    }
    return value;
  }
  root.find(j.ImportDeclaration).forEach((path6) => {
    const source = path6.value.source;
    if (j.StringLiteral.check(source)) {
      const transformed = transformPackageName(source.value);
      if (transformed !== source.value) {
        source.value = transformed;
      }
    }
  });
  root.find(j.CallExpression, {
    callee: { name: "require" }
  }).forEach((path6) => {
    const args = path6.value.arguments;
    if (args.length > 0 && j.StringLiteral.check(args[0])) {
      const transformed = transformPackageName(args[0].value);
      if (transformed !== args[0].value) {
        args[0].value = transformed;
      }
    }
  });
  root.find(j.ImportExpression).forEach((path6) => {
    const source = path6.value.source;
    if (j.StringLiteral.check(source)) {
      const transformed = transformPackageName(source.value);
      if (transformed !== source.value) {
        source.value = transformed;
      }
    }
  });
  return root;
};

// src/MigrateCommand/presets/granite/packageJsonProcessor.ts
init_esm_shims();
var import_picocolors4 = __toESM(require_picocolors(), 1);
var processPackageJson = async (cwd, config) => {
  logger.log("Processing package.json...");
  const packageJsonPath = `${cwd}/package.json`;
  if (!await fileExists(packageJsonPath)) {
    logger.log("No package.json found");
    return;
  }
  try {
    const content = await readFile(packageJsonPath);
    const packageJson = JSON.parse(content);
    let modified = false;
    const depFields = ["dependencies", "devDependencies", "peerDependencies"];
    for (const field of depFields) {
      if (packageJson[field]) {
        const deps = packageJson[field];
        const newDeps = {
          "@granite-js/plugin-router": TARGET_VERSION.granitePackages
        };
        for (const [originLibName, originLibVersion] of Object.entries(deps)) {
          let libName = originLibName;
          let libVersion = originLibVersion;
          if (originLibName === "react-native-bedrock") {
            libName = "@granite-js/react-native";
            libVersion = TARGET_VERSION.granitePackages;
          } else if (originLibName.startsWith("@react-native-bedrock/")) {
            if (UNSUPPORTED_LIBRARIES.includes(originLibName)) {
              const packageName = import_picocolors4.default.gray(`(${originLibName})`);
              logger.warn(`Unsupported library found in package.json ${packageName}`);
            } else {
              libName = originLibName.replace("@react-native-bedrock", "@granite-js");
              libVersion = TARGET_VERSION.granitePackages;
            }
          }
          if (libName.startsWith("@apps-in-toss/")) {
            libVersion = TARGET_VERSION.appsInTossPackages;
          } else if (libName === "@toss-design-system/react-native") {
            libVersion = TARGET_VERSION.tossDesignSystem;
          }
          newDeps[libName] = libVersion;
          modified ||= libName !== originLibName;
        }
        packageJson[field] = newDeps;
      }
    }
    if (packageJson.scripts) {
      const scripts = packageJson.scripts;
      for (const [key, value] of Object.entries(scripts)) {
        if (typeof value === "string" && value.includes("bedrock")) {
          scripts[key] = value.replace(/\bbedrock\b/g, "granite");
          modified ||= true;
        }
      }
    }
    if (config.dryRun) {
      return;
    }
    if (modified) {
      await writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2) + "\n");
      logger.success("Updated package.json");
    } else {
      logger.log("No changes needed in package.json");
    }
  } catch (error) {
    logger.error(`Failed to process package.json: ${error}`);
  }
};

// src/MigrateCommand/presets/granite/toAppsInTossFrameworkImport.ts
init_esm_shims();
var APPS_IN_TOSS_FRAMEWORK_EXPORTS = [
  "closeView",
  "getLocale",
  "getSchemeUri",
  "generateHapticFeedback",
  "share",
  "setSecureScreen",
  "setScreenAwakeMode",
  "getNetworkStatus",
  "setIosSwipeGestureEnabled",
  "openURL",
  "getPlatformOS"
];
var toAppsInTossFrameworkImport = (root, { j }, { fileName = "<unknown>" }) => {
  const appsInTossFrameworkMembers = [];
  root.find(j.ImportDeclaration).forEach((path6) => {
    const source = path6.node.source.value;
    if (typeof source !== "string") {
      return;
    }
    if (source === "@granite-js/react-native") {
      if (Array.isArray(path6.node.specifiers)) {
        path6.node.specifiers = path6.node.specifiers.filter((specifier) => {
          if (shouldImportFromAppsInTossFramework(fileName, specifier)) {
            appsInTossFrameworkMembers.push(specifier);
            return false;
          }
          return true;
        });
      }
      if (path6.node.specifiers?.length === 0) {
        j(path6).remove();
      }
    }
  });
  if (appsInTossFrameworkMembers.length > 0) {
    const importStatement = j.importDeclaration(appsInTossFrameworkMembers, j.literal("@apps-in-toss/framework"));
    root.find(j.Program).get("body", 0).insertBefore(importStatement);
  }
  return root;
};
function shouldImportFromAppsInTossFramework(fileName, specifier) {
  switch (specifier.type) {
    case "ImportSpecifier":
      return APPS_IN_TOSS_FRAMEWORK_EXPORTS.includes(String(specifier.imported.name));
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    default:
      logger.warn(`Unknown import specifier in ${fileName}`);
      return false;
  }
}

// src/MigrateCommand/codemod/index.ts
init_esm_shims();

// src/MigrateCommand/codemod/transform.ts
init_esm_shims();
import jscodeshift from "jscodeshift";
function transform(source, { transformers: transformers2, options = {} }) {
  const j = jscodeshift.withParser("tsx");
  const report = [];
  const stats = /* @__PURE__ */ new Map();
  const context = {
    j,
    jscodeshift: j,
    stats: (name, quantity = 1) => {
      if (quantity === 0) {
        return;
      }
      stats.set(name, (stats.get(name) ?? 0) + quantity);
    },
    report: (message) => {
      report.push(message);
    }
  };
  const root = transformers2.reduce((root2, transformer) => transformer(root2, context, options), j(source));
  return root.toSource();
}

// src/MigrateCommand/fs/fileScanner.ts
init_esm_shims();
import glob from "fast-glob";
var DEFAULT_EXTENSIONS = ["js", "ts", "jsx", "tsx", "cjs", "mjs"];
var DEFAULT_EXCLUDE_PATTERNS = ["**/node_modules/**", "**/.git/**", "**/dist/**"];
async function scanFiles(directory, options = {}) {
  const { extensions = DEFAULT_EXTENSIONS, excludePatterns = DEFAULT_EXCLUDE_PATTERNS } = options;
  const patterns = extensions.map((ext) => `**/*.${ext}`);
  const files = await glob(patterns, {
    cwd: directory,
    absolute: true,
    ignore: excludePatterns
  });
  return files;
}

// src/MigrateCommand/presets/granite/migrateGranite.ts
var transformers = [
  configTransformer,
  identifierReplacementsTransformer,
  packageImportsTransformer,
  toAppsInTossFrameworkImport
];
var migrateGranite = async (cwd, config) => {
  assert2(isBedrockProject(cwd), "This is not a Bedrock project");
  let processedCount = 0;
  const files = await scanFiles(cwd);
  logger.log(`Found ${files.length} source files`);
  logger.log("Processing source files...");
  for (const file of files) {
    try {
      const content = await readFile(file);
      const newContent = await transform(content, {
        transformers,
        options: {
          fileName: file
        }
      });
      if (config.dryRun !== true && newContent !== content) {
        await writeFile(file, newContent);
        processedCount++;
      }
    } catch (error) {
      logger.error(`Failed to process file: ${file}`, error);
    }
  }
  if (processedCount > 0) {
    logger.success(`Processed ${processedCount} source files`);
  } else {
    logger.log("No source files needed processing");
  }
  await processPackageJson(cwd, config);
  await processGitignore(cwd, config);
  await processBedrockConfig(cwd, config);
  logger.log(dedent`
  Please check the following steps:

  - Install dependencies
  - Run type checks
  - Run lint checks if a lint config exists
  - Verify test results if tests are present\n
  `);
};

// src/MigrateCommand/presets/index.ts
var MIGRATE_PRESETS = {
  granite: migrateGranite
};

// src/MigrateCommand/MigrateCommand.ts
var MigrateCommand = class extends Command3 {
  static paths = [[`migrate`]];
  static usage = Command3.Usage({
    category: "Migration",
    description: "Run migration",
    examples: [
      ["Run migration", "ait migrate <target>"],
      ["Check migration availability", "ait migrate <target> --dryRun"]
    ]
  });
  target = Option3.String({ required: true });
  dryRun = Option3.Boolean("--dry-run", { required: false });
  async execute() {
    try {
      const cwd = process.cwd();
      const config = {
        dryRun: this.dryRun
      };
      logger.log("Starting migration...");
      logger.log(`Working directory: ${cwd}`);
      const migrate = MIGRATE_PRESETS[this.target];
      if (migrate == null) {
        throw new Error(`Unknown target: ${this.target}`);
      }
      await migrate(cwd, config);
      logger.success("Migration completed successfully!");
      return 0;
    } catch (error) {
      logger.error(`Migration failed: ${error.message}`);
      return 1;
    }
  }
};

// src/TokenCommand.ts
init_esm_shims();
var import_debug4 = __toESM(require_src(), 1);
import * as p3 from "@clack/prompts";
import { Command as Command4, Option as Option4 } from "clipanion";
var debug4 = (0, import_debug4.default)("cli:token");
var TokenCommand = class extends Command4 {
  static paths = [["token"]];
  static usage = Command4.Usage({
    description: "\uD1A0\uD070 \uAD00\uB828 \uD558\uC704 \uBA85\uB839\uC744 \uAD00\uB9AC\uD569\uB2C8\uB2E4.",
    examples: [
      ["\uD1A0\uD070 \uCD94\uAC00", "ait token add <workspace?>"],
      ["\uD1A0\uD070 \uC0AD\uC81C", "ait token remove <workspace?>"]
    ]
  });
  async execute() {
    debug4("execute");
  }
};
var TokenAddCommand = class extends Command4 {
  static paths = [["token", "add"]];
  static usage = Command4.Usage({
    description: "\uC2DC\uD06C\uB9BF \uD1A0\uD070\uC744 \uCD94\uAC00\uD569\uB2C8\uB2E4.",
    examples: [
      ["\uAE30\uBCF8 \uBCC4\uCE6D\uC73C\uB85C \uD1A0\uD070 \uCD94\uAC00", "ait token add"],
      ["\uBCC4\uCE6D\uC744 \uC9C0\uC815\uD558\uC5EC \uD1A0\uD070 \uCD94\uAC00", "ait token add dev"]
    ]
  });
  workspace = Option4.String({ required: false });
  apiKey = Option4.String("--api-key", { required: false });
  async execute() {
    const workspace = this.workspace || "default";
    const secret = this.apiKey ? this.apiKey : await p3.password({
      message: "Enter secret token:",
      validate: (value) => {
        if (value.length === 0) {
          return "\uD1A0\uD070\uC740 \uBE44\uC5B4 \uC788\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.";
        }
        return;
      }
    });
    if (p3.isCancel(secret)) {
      return;
    }
    TokenStorage.set(workspace, secret);
    debug4("token add", { workspace });
    this.context.stdout.write(`${workspace} \uC6CC\uD06C\uC2A4\uD398\uC774\uC2A4\uB85C\uC758 \uC694\uCCAD\uC740 \uC774\uC81C \uBE44\uBC00 \uD1A0\uD070\uC744 \uC0AC\uC6A9\uD558\uC5EC \uC778\uC99D\uB429\uB2C8\uB2E4.
`);
  }
};
var TokenRemoveCommand = class extends Command4 {
  static paths = [["token", "remove"]];
  static usage = Command4.Usage({
    description: "\uC2DC\uD06C\uB9BF \uD1A0\uD070\uC744 \uC0AD\uC81C\uD569\uB2C8\uB2E4.",
    examples: [
      ["\uAE30\uBCF8 \uC6CC\uD06C\uC2A4\uD398\uC774\uC2A4\uC758 \uD1A0\uD070 \uC0AD\uC81C", "ait token remove"],
      ["\uBCC4\uCE6D\uC744 \uC9C0\uC815\uD558\uC5EC \uD1A0\uD070 \uC0AD\uC81C", "ait token remove dev"]
    ]
  });
  workspace = Option4.String({ required: false });
  async execute() {
    const workspace = this.workspace || "default";
    const removed = TokenStorage.delete(workspace);
    debug4("token remove", { workspace });
    if (removed) {
      this.context.stdout.write(`\uC6CC\uD06C\uC2A4\uD398\uC774\uC2A4\uC758 \uD1A0\uD070\uC744 \uC81C\uAC70\uD588\uC2B5\uB2C8\uB2E4: ${workspace}.
`);
    } else {
      this.context.stdout.write(`\uC6CC\uD06C\uC2A4\uD398\uC774\uC2A4\uC758 \uD1A0\uD070\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4: ${workspace}.
`);
    }
  }
};

// src/integrations/UploadSentrySourcemap/index.ts
init_esm_shims();

// src/integrations/UploadSentrySourcemap/UploadSentrySourcemap.ts
init_esm_shims();
import * as fs10 from "fs/promises";
import * as p4 from "@clack/prompts";
import { Command as Command5, Option as Option5 } from "clipanion";

// src/integrations/UploadSentrySourcemap/downloadArtifacts.ts
init_esm_shims();
var import_debug5 = __toESM(require_src(), 1);
import * as fs7 from "fs";
import * as os2 from "os";
import * as path4 from "path";
import { pipeline } from "stream";
import { promisify } from "util";
var debug5 = (0, import_debug5.default)("integrations:sentry");
var streamPipeline = promisify(pipeline);
async function downloadArtifacts(options) {
  const { appName, deploymentId, apiKey, baseUrl = DEFAULT_API_BASE_URL } = options;
  const params = new URLSearchParams({
    appName,
    deploymentId
  });
  const requestUrl = `${baseUrl}/api-public/v3/openapi/bundles/download?${params.toString()}`;
  debug5("Request URL", { requestUrl });
  const response = await fetch(`${baseUrl}/api-public/v3/openapi/bundles/download?${params.toString()}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`
    }
  });
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  if (response.body == null) {
    throw new Error("No response body");
  }
  const tmpDir = await createTempDirectory();
  const tmpFile = `${deploymentId}.zip`;
  const tmpFilePath = path4.join(tmpDir.path, tmpFile);
  const fileStream = fs7.createWriteStream(tmpFilePath);
  await streamPipeline(response.body, fileStream);
  debug5("Artifacts downloaded", { tmpFilePath });
  return tmpFilePath;
}
function createTempDirectory() {
  const tempDir = path4.join(os2.tmpdir(), "apps-in-toss", "sentry-integration");
  fs7.mkdirSync(tempDir, { recursive: true });
  debug5("Temp directory created", { tempDir });
  return {
    path: tempDir,
    cleanup: () => {
      fs7.rmSync(tempDir, { recursive: true, force: true });
    }
  };
}

// src/integrations/UploadSentrySourcemap/extractSentryDebugId.ts
init_esm_shims();
import fs8 from "fs/promises";
async function extractSentryDebugId(bundlePath) {
  const bundleContent = await fs8.readFile(bundlePath, "utf-8");
  return bundleContent.match(/SENTRY_DEBUG_ID=([\w-]+)/)?.[1];
}

// src/integrations/UploadSentrySourcemap/extractSources.ts
init_esm_shims();
import * as fs9 from "fs";
import * as path5 from "path";
import { pipeline as pipeline2 } from "stream";
import { promisify as promisify2 } from "util";
import * as zlib from "zlib";
import * as unzipper from "unzipper";
var pipe = promisify2(pipeline2);
async function extractSources(zipPath) {
  const sources = {
    android: {
      packagerBundle: "",
      packagerSourceMap: "",
      hermesBundle: "",
      hermesSourceMap: ""
    },
    ios: {
      packagerBundle: "",
      packagerSourceMap: "",
      hermesBundle: "",
      hermesSourceMap: ""
    }
  };
  await fs9.createReadStream(zipPath).pipe(unzipper.Parse()).on("entry", async (entry) => {
    const isRoot = !entry.path.includes("/");
    const fileName = path5.basename(entry.path);
    const outputPath = path5.join(path5.dirname(zipPath), fileName);
    if (isRoot) {
      entry.pipe(fs9.createWriteStream(outputPath));
      const platform = fileName.includes("android") ? "android" : "ios";
      if (fileName.endsWith(".js")) {
        sources[platform].packagerBundle = outputPath;
      } else if (fileName.endsWith(".hbc.gz")) {
        sources[platform].hermesBundle = outputPath;
      } else if (fileName.endsWith(".js.map")) {
        sources[platform].packagerSourceMap = outputPath;
      } else if (fileName.endsWith(".hbc.map")) {
        sources[platform].hermesSourceMap = outputPath;
      }
    } else {
      entry.autodrain();
    }
  }).promise();
  if (Object.values({ ...sources.android, ...sources.ios }).some((source) => source === "")) {
    throw new Error("invalid artifact");
  }
  const [androidHermesBundle, iosHermesBundle] = await Promise.all([
    decompressGzip(sources.android.hermesBundle),
    decompressGzip(sources.ios.hermesBundle)
  ]);
  sources.android.hermesBundle = androidHermesBundle;
  sources.ios.hermesBundle = iosHermesBundle;
  return sources;
}
async function decompressGzip(gzFile) {
  const outfile = gzFile.replace(/\.gz$/g, "");
  await pipe(fs9.createReadStream(gzFile), zlib.createGunzip(), fs9.createWriteStream(outfile));
  return outfile;
}

// src/integrations/UploadSentrySourcemap/injectSentryDebugId.ts
init_esm_shims();
function injectSentryDebugId(rawSourceMap, debugId) {
  rawSourceMap.debugId = debugId;
  return rawSourceMap;
}

// src/integrations/UploadSentrySourcemap/mergeSourcemap.ts
init_esm_shims();
import { SourceMapConsumer, SourceMapGenerator } from "source-map";
async function mergeSourceMaps(packagerSourceMap, hermesSourceMap) {
  const packagerMapConsumer = await new SourceMapConsumer(packagerSourceMap);
  const hermesMapConsumer = await new SourceMapConsumer(hermesSourceMap);
  const generator = SourceMapGenerator.fromSourceMap(hermesMapConsumer);
  generator.applySourceMap(packagerMapConsumer, hermesMapConsumer.sources[0]);
  return generator.toJSON();
}

// src/integrations/UploadSentrySourcemap/uploadSourcemap.ts
init_esm_shims();
import SentryCLI from "@sentry/cli";
function uploadSourcemap(bundlePath, sourcemapPath, options) {
  const client = new SentryCLI(null, options);
  return client.execute(["sourcemaps", "upload", "--debug-id-reference", bundlePath, sourcemapPath], true);
}

// src/integrations/UploadSentrySourcemap/UploadSentrySourcemap.ts
var UploadSentrySourcemap = class extends Command5 {
  static paths = [["sentry", "upload-sourcemap"]];
  apiKey = Option5.String("--api-key", {
    required: false,
    description: "\uC778\uC99D API \uD0A4"
  });
  appName = Option5.String("--app-name", {
    required: false,
    description: "\uC571 \uC774\uB984"
  });
  deploymentId = Option5.String("--deployment-id", {
    required: false,
    description: "\uBC30\uD3EC ID"
  });
  sentryAuthToken = Option5.String("--sentry-auth-token", {
    required: false,
    description: "Sentry \uC778\uC99D\uD0A4"
  });
  sentryOrg = Option5.String("--sentry-org", {
    required: false,
    description: "Sentry \uC870\uC9C1"
  });
  sentryProject = Option5.String("--sentry-project", {
    required: false,
    description: "Sentry \uD504\uB85C\uC81D\uD2B8"
  });
  baseUrl = Option5.String("--base-url", {
    description: "API Base URL"
  });
  async execute() {
    const { baseUrl } = this;
    const apiKey = this.apiKey || await this.promptRequiredValue("password", "\uC571\uC778\uD1A0\uC2A4 API \uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694", "API \uD0A4\uB294 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.");
    const appName = this.appName || await this.promptRequiredValue("text", "\uC571 \uC774\uB984\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694", "\uC571 \uC774\uB984\uC740 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.");
    const deploymentId = this.deploymentId || await this.promptRequiredValue("text", "\uBC30\uD3EC ID\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694", "\uBC30\uD3EC ID\uB294 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.");
    const sentryAuthToken = this.sentryAuthToken || process.env.SENTRY_AUTH_TOKEN || await this.promptRequiredValue("password", "Sentry \uC778\uC99D\uD0A4\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694", "\uC778\uC99D\uD0A4\uB294 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.");
    const sentryOrg = this.sentryOrg || process.env.SENTRY_ORG || await this.promptRequiredValue("text", "Sentry \uC870\uC9C1\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694", "\uC870\uC9C1\uC740 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.");
    const sentryProject = this.sentryProject || process.env.SENTRY_PROJECT || await this.promptRequiredValue("text", "Sentry \uD504\uB85C\uC81D\uD2B8\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694", "\uD504\uB85C\uC81D\uD2B8\uB294 \uD544\uC218 \uC785\uB825 \uD56D\uBAA9\uC785\uB2C8\uB2E4.");
    try {
      const zipPath = await downloadArtifacts({ apiKey, appName, deploymentId, baseUrl });
      const sources = await extractSources(zipPath);
      await p4.tasks([
        {
          title: "Android \uC18C\uC2A4\uB9F5 \uC5C5\uB85C\uB4DC \uC911...",
          task: async () => {
            await this.prepareSourceMapForUpload(sources.android);
            await uploadSourcemap(sources.android.hermesBundle, sources.android.hermesSourceMap, {
              authToken: sentryAuthToken,
              org: sentryOrg,
              project: sentryProject
            });
            return "Android \uC18C\uC2A4\uB9F5 \uC5C5\uB85C\uB4DC \uC644\uB8CC";
          }
        },
        {
          title: "iOS \uC18C\uC2A4\uB9F5 \uC5C5\uB85C\uB4DC \uC911...",
          task: async () => {
            await this.prepareSourceMapForUpload(sources.ios);
            await uploadSourcemap(sources.ios.hermesBundle, sources.ios.hermesSourceMap, {
              authToken: sentryAuthToken,
              org: sentryOrg,
              project: sentryProject
            });
            return "iOS \uC18C\uC2A4\uB9F5 \uC5C5\uB85C\uB4DC \uC644\uB8CC";
          }
        }
      ]);
      p4.outro("Sentry \uC18C\uC2A4\uB9F5 \uC5C5\uB85C\uB4DC \uC644\uB8CC");
    } catch (error) {
      if (error instanceof Error) {
        p4.log.error(error.message);
      } else {
        console.error(error);
      }
      process.exit(1);
    }
  }
  async prepareSourceMapForUpload(sources) {
    const debugId = await extractSentryDebugId(sources.packagerBundle);
    if (debugId == null) {
      throw new Error("Sentry Debug ID\uB97C \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4");
    }
    const mergedSourceMap = await mergeSourceMaps(
      await fs10.readFile(sources.packagerSourceMap, "utf-8"),
      await fs10.readFile(sources.hermesSourceMap, "utf-8")
    );
    const injectedSourceMap = injectSentryDebugId(mergedSourceMap, debugId);
    await fs10.writeFile(sources.hermesSourceMap, JSON.stringify(injectedSourceMap, null, 2), "utf-8");
  }
  async promptRequiredValue(type, message, validateMessage) {
    const result = await p4[type]({
      message,
      validate: (value) => {
        if (value.length === 0) {
          return validateMessage;
        }
        return;
      }
    });
    if (p4.isCancel(result)) {
      throw new Error("\uC791\uC5C5\uC774 \uCDE8\uC18C\uB418\uC5C8\uC5B4\uC694.");
    }
    return result;
  }
};

// src/index.ts
function initialize() {
  const cli = new Cli({
    binaryLabel: "ait",
    binaryName: "ait"
  });
  cli.register(DeployCommand);
  cli.register(InitCommand);
  cli.register(MigrateCommand);
  cli.register(UploadSentrySourcemap);
  cli.register(TokenCommand);
  cli.register(TokenAddCommand);
  cli.register(TokenRemoveCommand);
  cli.register(Builtins.HelpCommand);
  cli.runExit(process.argv.slice(2));
}
export {
  initialize
};
