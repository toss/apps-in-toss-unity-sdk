import * as react from 'react';
import { ComponentType, PropsWithChildren } from 'react';
import * as react_jsx_runtime from 'react/jsx-runtime';
import * as _apps_in_toss_analytics from '@apps-in-toss/analytics';
export * from '@apps-in-toss/analytics';
import { InitialProps, GraniteProps } from '@granite-js/react-native';
import { WebViewProps as WebViewProps$1 } from '@granite-js/native/react-native-webview';
import { ExternalWebViewScreenProps } from '@toss/tds-react-native';
import { StartUpdateLocationOptions, Location } from '@apps-in-toss/types';
export * from '@apps-in-toss/types';
import { onVisibilityChangedByTransparentServiceWeb } from '@apps-in-toss/native-modules';
export * from '@apps-in-toss/native-modules';
export { OverlayProvider, useOverlay } from '@toss/tds-react-native/private';

interface AppsInTossProps {
    context: GraniteProps['context'];
    analytics?: {
        /**
         * 분석 로그 출력 여부를 설정해요. 기본값은 `__DEV__` 예요.
         */
        debug?: boolean;
    };
}
declare function registerApp(container: ComponentType<PropsWithChildren<InitialProps>>, { context, analytics }: AppsInTossProps): ComponentType<PropsWithChildren<InitialProps>>;

declare const AppsInToss: {
    registerApp: typeof registerApp;
};

type GameWebViewProps$1 = WebViewProps$1;

type WebViewProps = PartnerWebViewProps | ExternalWebViewProps | GameWebViewProps;
interface PartnerWebViewProps extends Omit<WebViewProps$1, InternalProps> {
    type: 'partner';
    local: LocalNetwork;
}
interface ExternalWebViewProps extends Omit<ExternalWebViewScreenProps, InternalProps> {
    type: 'external';
    local: LocalNetwork;
}
interface GameWebViewProps extends Omit<GameWebViewProps$1, InternalProps> {
    type: 'game';
    local: LocalNetwork;
}
interface LocalNetwork {
    port: number;
    host: string;
}
type InternalProps = 'source' | 'cacheEnabled' | 'sharedCookiesEnabled' | 'thirdPartyCookiesEnabled' | 'injectedJavaScriptBeforeContentLoaded';
declare function WebView({ type, local, onMessage, ...props }: WebViewProps): react_jsx_runtime.JSX.Element;

declare function useCreateUserAgent({ batteryModePreference, colorPreference, locale, navbarPreference, pureSafeArea, safeArea, safeAreaBottomTransparency, }: {
    batteryModePreference?: string;
    colorPreference?: string;
    locale?: string;
    navbarPreference?: string;
    pureSafeArea?: string;
    safeArea?: string;
    safeAreaBottomTransparency?: string;
}): string;

type UseGeolocationOptions = Omit<StartUpdateLocationOptions, 'callback'>;
/**
 * @public
 * @category 위치 정보
 * @name useGeolocation
 * @description 디바이스의 위치 정보를 반환하는 훅이에요. 위치가 변경되면 값도 변경돼요.
 * GPS 정보를 활용해 현재 위치를 감지하고, 사용자의 이동에 따라 자동으로 업데이트돼요.
 * 예를 들어, 지도 기반 서비스에서 사용자의 현재 위치를 표시하거나, 배달 앱에서 실시간 이동 경로를 추적할 때 활용할 수 있어요.
 * 위치 정보의 정확도와 업데이트 주기를 조정할 수 있어서 배터리 소모를 최소화하면서도 필요한 수준의 정확도를 유지할 수 있어요.
 *
 * @param {UseGeolocationOptions} options - 위치 정보 감지에 필요한 설정 객체에요.
 * @param {Accuracy} [options.accuracy] 위치 정확도를 설정해요. `Accuracy.Lowest`: 오차범위 3KM 이내, `Accuracy.Low`: 오차범위 1KM 이내, `Accuracy.Balanced`: 오차범위 몇 백미터 이내, `Accuracy.High`: 오차범위 10M 이내, `Accuracy.Highest`: 가장 높은 정확도, `Accuracy.BestForNavigation`: 네비게이션을 위한 최고 정확도
 * @param {number} [options.timeInterval] 위치 정보를 업데이트하는 최소 주기로, 단위는 밀리초(ms)예요. 이 값은 위치 업데이트가 발생하는 가장 짧은 간격을 설정하지만, 시스템이나 환경의 영향을 받아 지정한 주기보다 더 긴 간격으로 업데이트될 수 있어요.
 * @param {number} [options.distanceInterval] 위치 변경 거리를 미터(m) 단위로 설정해요.
 * @returns {Location | null} 디바이스의 위치 정보가 담긴 객체를 반환해요. 자세한 내용은 [Location](/react-native/reference/framework/Types/Location.html)을 참고해주세요.
 *
 * @example
 * ### 위치 정보 변경 감지하기
 *
 * ```ts
 * import React, { useState, useCallback } from 'react';
 * import { View, Text } from 'react-native';
 * import { useGeolocation, Accuracy } from '@apps-in-toss/framework';
 *
 * // 위치 정보 변경 감지하기
 * function LocationWatcher() {
 *   const location = useGeolocation({
 *     accuracy: Accuracy.Balanced,
 *     distanceInterval: 10,
 *     timeInterval: 1000,
 *   });
 *
 *   if (location == null) {
 *     return <Text>위치 정보를 가져오는 중이에요...</Text>;
 *   }
 *
 *   return (
 *     <View>
 *       <Text>위치 정보: {location.latitude}, {location.longitude}</Text>
 *     </View>
 *   );
 * }
 * ```
 */
declare function useGeolocation({ accuracy, distanceInterval, timeInterval }: UseGeolocationOptions): Location | null;

/**
 * @public
 * @category 화면 제어
 * @name useWaitForReturnNavigator
 * @description
 * 화면 전환을 하고 돌아왔을 때 다음 코드를 동기적으로 실행할 수 있도록 도와주는 Hook 이에요.
 * 화면 이동은 [@react-navigation/native `useNavigation`의 `navigate`](https://reactnavigation.org/docs/6.x/navigation-prop#navigate)를 사용해요.
 *
 * 예를 들어, 사용자가 다른 화면으로 이동했다가 돌아왔다는 로그를 남기고 싶을 때 사용해요.
 *
 * @example
 * ### 화면 이동 후 돌아왔을 때 코드가 실행되는 예제
 *
 * **"이동하기"** 버튼을 누르면 다른 화면으로 이동하고, 돌아왔을 때 로그가 남겨져요.
 *
 * ```tsx
 * import { Button } from 'react-native';
 * import { useWaitForReturnNavigator } from 'react-native-bedrock';
 *
 * export function UseWaitForReturnNavigator() {
 *   const navigate = useWaitForReturnNavigator();
 *
 *   return (
 *     <>
 *       <Button
 *         title="이동하기"
 *         onPress={async () => {
 *           console.log(1);
 *           await navigate('/examples/use-visibility');
 *           // 화면에 돌아오면 이 코드가 실행됩니다.
 *           console.log(2);
 *         }}
 *       />
 *     </>
 *   );
 * }
 * ```
 */
declare function useWaitForReturnNavigator<T extends Record<string, object | undefined>>(): <RouteName extends keyof T>(route: RouteName, params?: T[RouteName]) => Promise<void>;

declare function useTopNavigation(): {
    addAccessoryButton: (button: {
        title: string;
        icon: {
            source: {
                uri: string;
            };
            name?: never;
        } | {
            name: string;
            source?: never;
        };
        id: string;
        onPress?: () => void;
        disabled?: boolean;
    } | undefined) => void;
    removeAccessoryButton: () => void;
};

declare const env: {
    getDeploymentId: () => string;
};

declare const INTERNAL__onVisibilityChangedByTransparentServiceWeb: typeof onVisibilityChangedByTransparentServiceWeb;

interface LoadFullScreenAdOptions {
    adGroupId: string;
}
interface LoadFullScreenAdEvent {
    type: 'loaded';
}
interface LoadFullScreenAdParams {
    options: LoadFullScreenAdOptions;
    onEvent: (data: LoadFullScreenAdEvent) => void;
    onError: (err: unknown) => void;
}
declare const loadFullScreenAd: {
    (params: LoadFullScreenAdParams): () => void;
    isSupported: () => boolean;
};
interface ShowFullScreenAdOptions {
    adGroupId: string;
}
type AdMobFullScreenEvent = AdClicked | AdDismissed | AdFailedToShow | AdImpression | AdShow;
type AdClicked = {
    type: 'clicked';
};
type AdDismissed = {
    type: 'dismissed';
};
type AdFailedToShow = {
    type: 'failedToShow';
};
type AdImpression = {
    type: 'impression';
};
type AdShow = {
    type: 'show';
};
type AdUserEarnedReward = {
    type: 'userEarnedReward';
    data: {
        unitType: string;
        unitAmount: number;
    };
};
type ShowFullScreenAdEvent = AdMobFullScreenEvent | AdUserEarnedReward | {
    type: 'requested';
};
interface ShowFullScreenAdParams {
    options: ShowFullScreenAdOptions;
    onEvent: (data: ShowFullScreenAdEvent) => void;
    onError: (err: unknown) => void;
}
declare function showFullScreenAd(params: ShowFullScreenAdParams): () => void;
declare namespace showFullScreenAd {
    var isSupported: () => boolean;
}

interface FetchTossAdOptions {
    adGroupId: string;
    sdkId: string;
    availableStyleIds: string[];
}

interface TossAdEventLogParams {
    log_name: string;
    log_type: string;
    params: Record<string, unknown>;
}

declare const Analytics: {
    init: (options: _apps_in_toss_analytics.AnalyticsConfig) => void;
    Impression: ({ enabled, impression: impressionType, ...props }: _apps_in_toss_analytics.LoggingImpressionProps) => react_jsx_runtime.JSX.Element;
    Press: react.ForwardRefExoticComponent<_apps_in_toss_analytics.LoggingPressProps & react.RefAttributes<unknown>>;
    Area: ({ children, params: _params, ...props }: _apps_in_toss_analytics.LoggingAreaProps) => react_jsx_runtime.JSX.Element;
};

export { Analytics, AppsInToss, type ExternalWebViewProps, type FetchTossAdOptions, type GameWebViewProps, INTERNAL__onVisibilityChangedByTransparentServiceWeb, type LoadFullScreenAdEvent, type LoadFullScreenAdOptions, type LoadFullScreenAdParams, type PartnerWebViewProps, type ShowFullScreenAdEvent, type ShowFullScreenAdOptions, type ShowFullScreenAdParams, type TossAdEventLogParams, type UseGeolocationOptions, WebView, type WebViewProps, env, loadFullScreenAd, showFullScreenAd, useCreateUserAgent, useGeolocation, useTopNavigation, useWaitForReturnNavigator };
