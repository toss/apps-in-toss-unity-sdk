[
  {
    "identifier": "closeView",
    "dts": "/**\n * @public\n * @category 화면 제어\n * @kind function\n * @name closeView\n * @description 현재 화면을 닫는 함수에요. 예를 들어, \"닫기\" 버튼을 눌러서 서비스를 종료할 때 사용할 수 있어요.\n * @returns {Promise<void>}\n *\n * @example\n * ### 닫기 버튼을 눌러 화면 닫기\n *\n * ```tsx\n * import { Button } from 'react-native';\n * import { closeView } from '@apps-in-toss/native-modules';\n *\n * function CloseButton() {\n *  return <Button title=\"닫기\" onPress={closeView} />;\n * }\n * ```\n */\nexport declare function closeView(): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "generateHapticFeedback",
    "dts": "export type HapticFeedbackType = \"tickWeak\" | \"tap\" | \"tickMedium\" | \"softMedium\" | \"basicWeak\" | \"basicMedium\" | \"success\" | \"error\" | \"wiggle\" | \"confetti\";\n/**\n * @public\n * @category 인터렉션\n * @name HapticFeedbackOptions\n * @description\n * generateHapticFeedback 함수에 전달할 햅틱진동의 타입을 나타내요. 진동타입의 종류는 다음과 같아요.\n * ```typescript\n * type HapticFeedbackType =\n * | \"tickWeak\"\n * | \"tap\"\n * | \"tickMedium\"\n * | \"softMedium\"\n * | \"basicWeak\"\n * | \"basicMedium\"\n * | \"success\"\n * | \"error\"\n * | \"wiggle\"\n * | \"confetti\";\n * ```\n * @typedef { type: HapticFeedbackType } HapticFeedbackOptions\n * @typedef { \"tickWeak\" | \"tap\" | \"tickMedium\" | \"softMedium\" | \"basicWeak\" | \"basicMedium\" | \"success\" | \"error\" | \"wiggle\" | \"confetti\" } HapticFeedbackType\n *\n */\nexport interface HapticFeedbackOptions {\n\ttype: HapticFeedbackType;\n}\n/**\n * @public\n * @category 인터렉션\n * @name generateHapticFeedback\n * @description 디바이스에 햅틱 진동을 일으키는 함수예요. 예를 들어, 버튼 터치나 화면전환에 드라마틱한 효과를 주고 싶을 때 사용할 수 있어요. [HapticFeedbackOptions](/react-native/reference/native-modules/인터렉션/HapticFeedbackOptions.html)에서 진동타입을 확인해 보세요.\n * @returns {void}\n *\n * @example\n * ### 버튼을 눌러 햅틱 일으키기\n *\n * ```tsx\n * import { Button } from 'react-native';\n * import { generateHapticFeedback } from '@apps-in-toss/native-modules';\n *\n * function GenerateHapticFeedback() {\n *  return <Button title=\"햅틱\" onPress={() => { generateHapticFeedback( { type: \"tickWeak\"}) }} />;\n * }\n * ```\n */\nexport declare function generateHapticFeedback(options: HapticFeedbackOptions): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "share",
    "dts": "/**\n * @public\n * @category 공유\n * @kind function\n * @name share\n * @description\n * 사용자가 콘텐츠를 다른 사람과 공유할 수 있도록 네이티브 공유 시트를 표시해요.\n * `options.message` 속성에 공유할 메시지를 전달하면, 사용자가 선택할 수 있는 앱 목록이 표시돼요.\n * 예를 들어, 사용자가 텍스트 메시지를 공유하거나 메모 앱에 저장하려고 할 때 유용해요.\n * @param {object} options - 공유할 메시지를 담은 객체예요.\n * @param {string} options.message - 공유할 텍스트 문자열이에요. 예를 들어, \"안녕하세요! 이 내용을 공유합니다.\"\n *\n * @example\n * ### 공유하기 기능 구현하기\n *\n * 아래는 버튼을 클릭하면 메시지를 공유하는 간단한 예제예요.\n *\n * ```tsx\n * import { share } from '@apps-in-toss/native-modules';\n * import { Button } from 'react-native';\n *\n * function MyPage() {\n *   return (\n *     <Button\n *       title=\"공유\"\n *       onPress={() => share({ message: '공유할 메시지입니다.' })}\n *     />\n *   );\n * }\n * ```\n */\nexport declare function share(message: {\n\tmessage: string;\n}): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "setSecureScreen",
    "dts": "/**\n * @public\n * @name setSecureScreen\n * @category 화면 제어\n * @kind function\n * @description\n * 화면 캡쳐를 차단해서 민감한 정보가 유출되지 않도록 보호하거나, 필요할 경우 캡쳐를 허용하도록 설정해요. 예를 들어 보안이 중요한 화면에서 사용할 수 있어요.\n *\n * @param {object} options 화면 캡쳐 설정 옵션이에요.\n * @param {boolean} options.enabled 화면 캡쳐를 차단할지 여부를 설정해요. `true`면 캡쳐를 차단하고, `false`면 허용해요.\n * @returns {enabled: boolean} 현재 설정된 캡쳐 차단 상태를 반환해요.\n *\n * @example\n * ### 캡쳐 허용 상태 변경하기\n *\n * ```tsx\n * import { Button } from 'react-native';\n * import { setSecureScreen } from '@apps-in-toss/native-modules';\n *\n * function SetSecureScreen() {\n *  return <Button title=\"캡쳐 막기\" onPress={async () => {\n *    await setSecureScreen({ enabled: true });\n *  }} />;\n * }\n * ```\n */\nexport declare function setSecureScreen(options: {\n\tenabled: boolean;\n}): Promise<{\n\tenabled: boolean;\n}>;\n\nexport {};\n"
  },
  {
    "identifier": "setScreenAwakeMode",
    "dts": "/**\n * @public\n * @category 화면 제어\n * @kind function\n * @name setScreenAwakeMode\n * @description\n * `setScreenAwakeMode` 함수는 화면이 항상 켜져 있도록 설정하거나 해제하는 기능을 제공해요.\n * 이 기능은 웹툰, 동영상, 문서 읽기 등 화면을 지속해서 켜두어야 하는 상황에서 유용해요.\n *\n * `enabled` 옵션을 `true`로 설정하면 화면이 꺼지지 않게 유지하고,  `false`로 설정하면 기본 화면 보호기 시간에 따라 화면이 꺼져요.  특히, 이 함수는 앱 전체에 영향을 미치므로 특정 화면에서만 사용하려면 화면을 벗어날 때 이전 상태로 복구하는 추가 작업이 필요해요.\n *\n * 예를 들어, 미디어 콘텐츠 감상 화면에서는 항상 켜짐 모드를 활성화하고, 화면을 떠날 때 설정을 복구해서 불필요한 배터리 소모를 방지할 수 있어요.\n *\n * 다만, 앱에서 벗어나는 상황에서는 항상 켜짐 모드가 비활성화될 수 있으니 주의해야 해요.\n *\n * @param {object} options 화면 항상 켜짐 모드의 설정 값이에요.\n * @param {boolean} options.enabled 화면 항상 켜짐 모드를 켜거나 끄는 옵션이에요.\n * `true`로 설정하면 화면이 항상 켜지고, `false`로 설정하면 화면 보호기 시간에 따라 꺼져요.\n *\n * @returns {object} 현재 화면 항상 켜짐 모드의 설정 상태를 반환해요.\n * @returns {boolean} enabled 화면 항상 켜짐 모드가 켜져 있는지 여부를 나타내는 값이에요.\n *\n * @example\n * ### 화면 항상 켜짐 모드 설정하기\n *\n * ```tsx\n * import { Button } from 'react-native';\n * import { setScreenAwakeMode } from '@apps-in-toss/native-modules';\n *\n * function SetScreenAwakeMode() {\n *   return (\n *     <Button\n *       title=\"화면 항상 켜기\"\n *       onPress={() => {\n *         setScreenAwakeMode({ enabled: true });\n *       }}\n *     />\n *   );\n * }\n * ```\n *\n * ### 화면 항상 켜짐 모드 복구하기\n * 특정 화면을 벗어날 때 이전 상태로 복구하려면 다음과 같이 `useEffect`를 사용하세요.\n *\n * ```tsx\n * import { useEffect } from 'react';\n * import { setScreenAwakeMode, cleanUp } from '@apps-in-toss/native-modules';\n *\n * function MediaScreen() {\n *   useEffect(() => {\n *     setScreenAwakeMode({ enabled: true });\n *\n *     return () => {\n *       setScreenAwakeMode({ enabled: false }); // 설정을 이전 상태로 복구해요.\n *     };\n *   }, []);\n *\n *   return <Text>미디어 콘텐츠를 감상하는 화면</Text>;\n * }\n * ```\n */\nexport declare function setScreenAwakeMode(options: {\n\tenabled: boolean;\n}): Promise<{\n\tenabled: boolean;\n}>;\n\nexport {};\n"
  },
  {
    "identifier": "getNetworkStatus",
    "dts": "export type NetworkStatus = \"OFFLINE\" | \"WIFI\" | \"2G\" | \"3G\" | \"4G\" | \"5G\" | \"WWAN\" | \"UNKNOWN\";\n/**\n * @public\n * @category 네트워크\n * @kind function\n * @name getNetworkStatus\n * @description\n * 디바이스의 현재 네트워크 연결 상태를 가져오는 함수예요.\n * 반환 값은 `NetworkStatus` 타입으로, 인터넷 연결 여부와 연결 유형(Wi-Fi, 모바일 데이터 등)을 나타내요. 값은 다음 중 하나예요.\n *\n * - `OFFLINE`: 인터넷에 연결되지 않은 상태예요.\n * - `WIFI`: Wi-Fi에 연결된 상태예요.\n * - `2G`: 2G 네트워크에 연결된 상태예요.\n * - `3G`: 3G 네트워크에 연결된 상태예요.\n * - `4G`: 4G 네트워크에 연결된 상태예요.\n * - `5G`: 5G 네트워크에 연결된 상태예요.\n * - `WWAN`: 인터넷은 연결되었지만, 연결 유형(Wi-Fi, 2G~5G)을 알 수 없는 상태예요. 이 상태는 iOS에서만 확인할 수 있어요.\n * - `UNKNOWN`: 인터넷 연결 상태를 알 수 없는 상태예요. 이 상태는 안드로이드에서만 확인할 수 있어요.\n *\n * @returns {Promise<NetworkStatus>} 네트워크 상태를 반환해요.\n *\n * @example\n * ### 현재 네트워크 상태 가져오기\n *\n * 네트워크 연결 상태를 가져와 화면에 표시하는 예제예요.\n *\n * ```tsx\n * import { useState, useEffect } from 'react';\n * import { Text, View } from 'react-native';\n * import { getNetworkStatus, NetworkStatus } from '@apps-in-toss/native-modules';\n *\n * function GetNetworkStatus() {\n *   const [status, setStatus] = useState<NetworkStatus | ''>('');\n *\n *   useEffect(() => {\n *     async function fetchStatus() {\n *       const networkStatus = await getNetworkStatus();\n *       setStatus(networkStatus);\n *     }\n *\n *     fetchStatus();\n *   }, []);\n *\n *   return (\n *     <View>\n *       <Text>현재 네트워크 상태: {status}</Text>\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare function getNetworkStatus(): Promise<NetworkStatus>;\n\nexport {};\n"
  },
  {
    "identifier": "setIosSwipeGestureEnabled",
    "dts": "/**\n * @public\n * @category 화면 제어\n * @name setIosSwipeGestureEnabled\n * @description\n * `setIosSwipeGestureEnabled` 함수는 iOS에서 화면을 스와이프하여 뒤로가기 기능을 활성화하거나 비활성화할 수 있어요.\n *\n * @param {object} options 스와이프하여 뒤로가기 기능을 활성화하거나 비활성화하는 옵션이에요.\n * @param {boolean} options.isEnabled 화면을 스와이프하여 뒤로가기 기능을 활성화하거나 비활성화할 수 있어요. `true`를 설정하면 스와이프로 뒤로갈 수 있고, `false`를 설정하면 스와이프 뒤로가기 기능이 비활성화돼요.\n *\n * @returns {void}\n *\n * @example\n *\n * ### iOS에서 화면 스와이프로 뒤로가기 기능을 활성화하거나 비활성화하기\n *\n * **스와이프 끄기** 버튼을 눌러 화면 스와이프로 뒤로가기 기능을 비활성화하거나, **스와이프 켜기** 버튼을 눌러 화면 스와이프로 뒤로가기 기능을 활성화할 수 있어요.\n *\n *\n * ```tsx\n * import { setIosSwipeGestureEnabled } from '@apps-in-toss/native-modules';\n * import { Button } from 'react-native';\n *\n * function Page() {\n *  return (\n *    <>\n *     <Button title=\"스와이프 끄기\" onPress={() => setIosSwipeGestureEnabled({ isEnabled: false })} />\n *     <Button title=\"스와이프 켜기\" onPress={() => setIosSwipeGestureEnabled({ isEnabled: true })} />\n *    </>\n *  );\n * }\n * ```\n *\n */\nexport declare function setIosSwipeGestureEnabled(options: {\n\tisEnabled: boolean;\n}): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "openURL",
    "dts": "/**\n * @public\n * @kind function\n * @category 화면 이동\n *\n * @name openURL\n * @signature\n * ```typescript\n * function openURL(url: string): Promise<any>;\n * ```\n *\n * @description\n * 지정된 URL을 기기의 기본 브라우저나 관련 앱에서 열어요.\n * 이 함수는 `react-native`의 [`Linking.openURL`](https://reactnative.dev/docs/0.72/linking#openurl) 메서드를 사용하여 URL을 열어요.\n *\n * @param {string} url 열고자 하는 URL 주소\n * @returns {Promise<any>} URL이 성공적으로 열렸을 때 해결되는 Promise\n *\n * @example\n *\n * ### 외부 URL 열기\n *\n * ```tsx\n * import { openURL } from '@apps-in-toss/native-modules';\n * import { Button } from 'react-native';\n *\n * function Page() {\n *   const handlePress = () => {\n *     openURL('https://google.com');\n *   };\n *\n *   return <Button title=\"구글 웹사이트 열기\" onPress={handlePress} />;\n * }\n * ```\n */\nexport declare function openURL(url: string): Promise<any>;\n\nexport {};\n"
  },
  {
    "identifier": "openPermissionDialog",
    "dts": "type PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionAccess = \"read\" | \"write\" | \"access\";\ntype PermissionName$1 = \"clipboard\" | \"contacts\" | \"photos\" | \"geolocation\" | \"camera\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\n/**\n * @category AppsInTossModules\n * @name openPermissionDialog\n * @description 권한 요청 다이얼로그를 표시하는 함수예요. 사용자는 이 다이얼로그에서 특정 권한을 허용하거나 거부할 수 있어요.\n * @param permission.name {PermissionName} 요청할 권한의 이름이에요. 예를 들어 `clipboard`는 클립보드 접근 권한을, `camera`는 카메라 접근 권한을 나타내요.\n * @param permission.access {PermissionAccess} 요청할 권한의 접근 유형이에요. 예를 들어 `read`는 읽기 권한, `write`는 쓰기 권한을 의미해요.\n * @returns {Promise<'allowed' | 'denied'>} 권한의 현재 상태를 반환해요. 반환값은 다음 중 하나예요:\n * - `allowed`: 권한이 허용된 상태예요.\n * - `denied`: 권한이 거부된 상태예요.\n *\n * @example\n * ### 클립보드 읽기 권한 다이얼로그 열기\n *\n * ```tsx\n * import React, { useState } from 'react';\n * import { View, Text, Button } from 'react-native';\n * import { openPermissionDialog, type PermissionStatus } from '@apps-in-toss/framework';\n *\n * function PermissionRequest() {\n *   const [permission, setPermission] = useState<PermissionStatus | null>(null);\n *\n *   const handleRequestPermission = async () => {\n *     try {\n *       // 클립보드 읽기 권한을 요청하는 다이얼로그를 표시해요.\n *       const status = await openPermissionDialog({\n *         name: 'clipboard',\n *         access: 'read',\n *       });\n *       setPermission(status); // 권한 상태를 업데이트해요.\n *     } catch (error) {\n *       console.error('권한 요청 중 오류가 발생했어요:', error);\n *     }\n *   };\n *\n *   return (\n *     <View>\n *       <Text>\n *         클립보드 읽기 권한 상태: {permission ? permission : '아직 요청하지 않음'}\n *       </Text>\n *       <Button title=\"권한 요청하기\" onPress={handleRequestPermission} />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare function openPermissionDialog(permission: {\n\tname: PermissionName$1;\n\taccess: PermissionAccess;\n}): ReturnType<PermissionDialogFunction>;\n\nexport {};\n"
  },
  {
    "identifier": "getPermission",
    "dts": "type PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionAccess = \"read\" | \"write\" | \"access\";\ntype PermissionName$1 = \"clipboard\" | \"contacts\" | \"photos\" | \"geolocation\" | \"camera\";\n/**\n * @category AppsInTossModules\n * @name getPermission\n * @description 특정 권한의 현재 상태를 확인하는 함수예요. 사용자가 권한을 허용했는지, 거부했는지, 또는 아직 선택하지 않았는지를 알 수 있어요.\n * @param permission.name {PermissionName} 요청할 권한의 이름이에요. 예를 들어 `clipboard`는 클립보드 접근 권한을, `camera`는 카메라 접근 권한을 나타내요.\n * @param permission.access {PermissionAccess} 요청할 권한의 접근 유형이에요. 예를 들어 `read`는 읽기 권한, `write`는 쓰기 권한을 의미해요.\n * @returns {Promise<'allowed' | 'denied' | 'notDetermined'>} 권한의 현재 상태를 반환해요. 반환값은 다음 중 하나예요:\n * - `allowed`: 권한이 허용된 상태예요.\n * - `denied`: 권한이 거부된 상태예요.\n * - `notDetermined`: 아직 권한 요청에 대한 결정이 이루어지지 않은 상태예요.\n *\n * @example\n * ### 클립보드 읽기 권한 상태 확인하기\n *\n * ```tsx\n * import React, { useEffect, useState } from 'react';\n * import { View, Text } from 'react-native';\n * import { getPermission, type PermissionStatus } from '@apps-in-toss/framework';\n *\n * function PermissionCheck() {\n *   const [permission, setPermission] = useState<PermissionStatus | null>(null);\n *\n *   useEffect(() => {\n *     async function checkPermission() {\n *       try {\n *         // 'clipboard'는 권한 이름, 'read'는 접근 유형을 나타내요.\n *         const status = await getPermission({\n *           name: 'clipboard', // 클립보드 접근 권한\n *           access: 'read', // 읽기 권한 요청\n *         });\n *         setPermission(status); // 권한 상태를 업데이트해요.\n *       } catch (error) {\n *         console.error('권한 상태를 확인하지 못했어요:', error);\n *       }\n *     }\n *\n *     checkPermission();\n *   }, []);\n *\n *   return (\n *     <View>\n *       <Text>\n *         클립보드 읽기 권한 상태: {permission ? permission : '확인 중...'}\n *       </Text>\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare function getPermission(permission: {\n\tname: PermissionName$1;\n\taccess: PermissionAccess;\n}): Promise<PermissionStatus$1>;\n\nexport {};\n"
  },
  {
    "identifier": "requestPermission",
    "dts": "type PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionAccess = \"read\" | \"write\" | \"access\";\ntype PermissionName$1 = \"clipboard\" | \"contacts\" | \"photos\" | \"geolocation\" | \"camera\";\n/**\n * @category PermissionManagement\n * @name requestPermission\n * @description 특정 권한을 요청하는 함수예요. 이미 허용되었거나 거부된 권한 상태를 확인한 뒤, 필요할 때 권한 요청 다이얼로그를 표시해요.\n * @param permission.name {PermissionName} 요청할 권한의 이름이에요. 예를 들어 `clipboard`는 클립보드 접근 권한을, `camera`는 카메라 접근 권한을 나타내요.\n * @param permission.access {PermissionAccess} 요청할 권한의 접근 유형이에요. 예를 들어 `read`는 읽기 권한, `write`는 쓰기 권한을 의미해요.\n * @returns {Promise<'allowed' | 'denied'>} 사용자가 선택한 최종 권한 상태를 반환해요.\n * 반환값은 다음 중 하나예요:\n * - `allowed`: 권한이 허용된 경우\n * - `denied`: 권한이 거부된 경우\n *\n * @example\n * ### 클립보드 읽기 권한 요청하기\n *\n * ```tsx\n * import React, { useState } from 'react';\n * import { View, Text, Button } from 'react-native';\n * import { requestPermission, type PermissionStatus } from '@apps-in-toss/framework';\n *\n * function PermissionRequest() {\n *   const [permissionStatus, setPermissionStatus] = useState<PermissionStatus | null>(null);\n *\n *   const handleRequestPermission = async () => {\n *     try {\n *       // 클립보드 읽기 권한을 요청해요.\n *       const permissionStatus = await requestPermission({\n *         name: 'clipboard', // 권한 이름: 클립보드\n *         access: 'read', // 접근 유형: 읽기\n *       });\n *       setPermissionStatus(permissionStatus); // 최종 권한 상태를 저장해요.\n *     } catch (error) {\n *       console.error('권한 요청 중 오류가 발생했어요:', error);\n *     }\n *   };\n *\n *   return (\n *     <View>\n *       <Text>\n *         클립보드 읽기 권한 상태: {permissionStatus ? permissionStatus : '아직 요청하지 않음'}\n *       </Text>\n *       <Button title=\"권한 요청하기\" onPress={handleRequestPermission} />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare function requestPermission(permission: {\n\tname: PermissionName$1;\n\taccess: PermissionAccess;\n}): Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\n\nexport {};\n"
  },
  {
    "identifier": "setClipboardText",
    "dts": "export type SetClipboardText = (text: string) => Promise<void>;\ntype PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\nexport type GetPermissionFunction = () => Promise<PermissionStatus$1>;\nexport type PermissionFunctionWithDialog<T extends (...args: any[]) => any> = T & {\n\tgetPermission: GetPermissionFunction;\n\topenPermissionDialog: PermissionDialogFunction;\n};\n/**\n * @public\n * @category 클립보드\n * @name setClipboardText\n * @description 텍스트를 클립보드에 복사해서 사용자가 다른 곳에 붙여 넣기 할 수 있어요.\n * @param {Promise<void>} text - 클립보드에 복사할 텍스트예요. 문자열 형식으로 입력해요.\n * @property [openPermissionDialog] - 클립보드 쓰기 권한을 다시 요청하는 다이얼로그를 표시해요. 사용자는 \"허용\", \"한 번만 허용\", \"안하기\" 중 하나를 선택할 수 있어요. \"허용\"이나 \"한 번만 허용\"을 선택하면 `allowed`를 반환하고, \"안하기\"를 선택하면 `denied`를 반환해요.\n * @property [getPermission] - 클립보드 쓰기 권한의 현재 상태를 반환해요. `allowed`는 사용자가 클립보드 쓰기 권한을 허용한 상태예요. `denied`는 사용자가 클립보드 쓰기 권한을 거부한 상태예요. `notDetermined`는 클립보드 쓰기 권한 요청을 한 번도 하지 않은 상태예요.\n *\n * @signature\n * ```typescript\n * function setClipboardText(text: string): Promise<void>;\n * ```\n *\n * @example\n * ### 텍스트를 클립보드에 복사하기\n *\n * 텍스트를 클립보드에 복사하는 예제예요.\n * \"권한 확인하기\"버튼을 눌러서 현재 클립보드 쓰기 권한을 확인해요.\n * 사용자가 권한을 거부했거나 시스템에서 권한이 제한된 경우에는 [`SetClipboardTextPermissionError`](/react-native/reference/types/권한/SetClipboardTextPermissionError)를 반환해요.\n * \"권한 요청하기\"버튼을 눌러서 클립보드 쓰기 권한을 요청할 수 있어요.\n *\n * ```tsx\n * import { setClipboardText, SetClipboardTextPermissionError } from '@apps-in-toss/framework';\n * import { Alert, Button } from 'react-native';\n *\n * // '복사' 버튼을 누르면 \"복사할 텍스트\"가 클립보드에 복사돼요.\n * function CopyButton() {\n *   const handleCopy = async () => {\n *     try {\n *       await setClipboardText('복사할 텍스트');\n *       console.log('텍스트가 복사됐어요!');\n *     } catch (error) {\n *       if (error instanceof SetClipboardTextPermissionError) {\n *         // 텍스트 쓰기 권한 거부됨\n *       }\n *     }\n *   };\n *\n *   return (\n *     <>\n *       <Button title=\"복사\" onPress={handleCopy} />\n *       <Button\n *         title=\"권한 확인하기\"\n *         onPress={async () => {\n *           const permission = await setClipboardText.getPermission();\n *           Alert.alert(permission);\n *         }}\n *       />\n *       <Button\n *         title=\"권한 요청하기\"\n *         onPress={async () => {\n *           const permission = await setClipboardText.openPermissionDialog();\n *           Alert.alert(permission);\n *         }}\n *       />\n *     </>\n *   );\n * }\n * ```\n */\nexport declare const setClipboardText: PermissionFunctionWithDialog<SetClipboardText>;\n\nexport {};\n"
  },
  {
    "identifier": "getClipboardText",
    "dts": "export type GetClipboardText = () => Promise<string>;\ntype PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\nexport type GetPermissionFunction = () => Promise<PermissionStatus$1>;\nexport type PermissionFunctionWithDialog<T extends (...args: any[]) => any> = T & {\n\tgetPermission: GetPermissionFunction;\n\topenPermissionDialog: PermissionDialogFunction;\n};\n/**\n * @public\n * @category 클립보드\n * @name getClipboardText\n * @description 클립보드에 저장된 텍스트를 가져오는 함수예요. 복사된 텍스트를 읽어서 다른 작업에 활용할 수 있어요.\n * @property [openPermissionDialog] - 클립보드 읽기 권한을 다시 요청하는 다이얼로그를 표시해요. 사용자는 \"허용\", \"한 번만 허용\", \"안하기\" 중 하나를 선택할 수 있어요. \"허용\"이나 \"한 번만 허용\"을 선택하면 `allowed`를 반환하고, \"안하기\"를 선택하면 `denied`를 반환해요.\n * @property [getPermission] - 클립보드 읽기 권한의 현재 상태를 반환해요. `allowed`는 사용자가 클립보드 읽기 권한을 허용한 상태예요. `denied`는 사용자가 클립보드 읽기 권한을 거부한 상태예요. `notDetermined`는 클립보드 읽기 권한 요청을 한 번도 하지 않은 상태예요.\n * @returns {Promise<string>} - 클립보드에 저장된 텍스트를 반환해요. 클립보드에 텍스트가 없으면 빈 문자열을 반환해요.\n *\n * @signature\n * ```typescript\n * function getClipboardText(): Promise<string>;\n * ```\n *\n * @example\n * ### 클립보드의 텍스트 가져오기\n *\n * 클립보드의 텍스트를 가져오는 예제예요.\n * \"권한 확인하기\"버튼을 눌러서 현재 클립보드 읽기 권한을 확인해요.\n * 사용자가 권한을 거부했거나 시스템에서 권한이 제한된 경우에는 [`GetClipboardTextPermissionError`](/react-native/reference/types/권한/GetClipboardTextPermissionError)를 반환해요.\n * \"권한 요청하기\"버튼을 눌러서 클립보드 읽기 권한을 요청할 수 있어요.\n *\n * ```tsx\n * import {\n *   getClipboardText,\n *   GetClipboardTextPermissionError,\n *   SetClipboardTextPermissionError,\n * } from '@apps-in-toss/framework';\n * import { useState } from 'react';\n * import { Alert, Button, Text, View } from 'react-native'; *\n\n * // '붙여넣기' 버튼을 누르면 클립보드에 저장된 텍스트를 가져와 화면에 표시해요.\n * function PasteButton() {\n *   const [text, setText] = useState(''); *\n\n *   const handlePress = async () => {\n *     try {\n *       const clipboardText = await getClipboardText();\n *       setText(clipboardText || '클립보드에 텍스트가 없어요.');\n *     } catch (error) {\n *       if (error instanceof GetClipboardTextPermissionError) {\n *         // 클립보드 읽기 권한 없음\n *       } *\n\n *       if (error instanceof SetClipboardTextPermissionError) {\n *         // 클립보드 쓰기 권한 없음\n *       }\n *     }\n *   }; *\n\n *   return (\n *     <View>\n *       <Text>{text}</Text>\n *       <Button title=\"붙여넣기\" onPress={handlePress} />\n *       <Button\n *         title=\"권한 확인하기\"\n *         onPress={async () => {\n *           const permission = await getClipboardText.getPermission();\n *           Alert.alert(permission);\n *         }}\n *       />\n *       <Button\n *         title=\"권한 요청하기\"\n *         onPress={async () => {\n *           const permission = await getClipboardText.openPermissionDialog();\n *           Alert.alert(permission);\n *         }}\n *       />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare const getClipboardText: PermissionFunctionWithDialog<GetClipboardText>;\n\nexport {};\n"
  },
  {
    "identifier": "fetchContacts",
    "dts": "export interface FetchContactsOptions {\n\tsize: number;\n\toffset: number;\n\tquery?: {\n\t\tcontains?: string;\n\t};\n}\n/**\n * 연락처 정보를 나타내는 타입이에요.\n */\nexport interface ContactEntity {\n\t/** 연락처 이름이에요. */\n\tname: string;\n\t/** 연락처 전화번호로, 문자열 형식이에요. */\n\tphoneNumber: string;\n}\nexport interface ContactResult {\n\tresult: ContactEntity[];\n\tnextOffset: number | null;\n\tdone: boolean;\n}\nexport type FetchContacts = (options: FetchContactsOptions) => Promise<ContactResult>;\ntype PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\nexport type GetPermissionFunction = () => Promise<PermissionStatus$1>;\nexport type PermissionFunctionWithDialog<T extends (...args: any[]) => any> = T & {\n\tgetPermission: GetPermissionFunction;\n\topenPermissionDialog: PermissionDialogFunction;\n};\n/**\n * @public\n * @category 연락처\n * @name fetchContacts\n * @description 사용자의 연락처 목록을 페이지 단위로 가져오는 함수예요.\n * @param options - 연락처를 가져올 때 지정하는 옵션 객체예요.\n * @param options.size - 한 번에 가져올 연락처 개수예요. 예를 들어, 10을 전달하면 최대 10개의 연락처를 가져와요.\n * @param options.offset - 가져올 연락처의 시작 지점이에요. 처음 호출할 때는 `0`을 전달해야 해요. 이후에는 이전 호출에서 반환된 `nextOffset` 값을 사용해요.\n * @param options.query - 추가적인 필터링 옵션이에요.\n * @param options.query.contains - 이름에 특정 문자열이 포함된 연락처만 가져오고 싶을 때 사용해요. 이 값을 전달하지 않으면 모든 연락처를 가져와요.\n * @property [openPermissionDialog] - 연락처 읽기 권한을 다시 요청하는 다이얼로그를 표시해요. 사용자는 \"허용\", \"한 번만 허용\", \"안하기\" 중 하나를 선택할 수 있어요. \"허용\"이나 \"한 번만 허용\"을 선택하면 `allowed`를 반환하고, \"안하기\"를 선택하면 `denied`를 반환해요.\n * @property [getPermission] - 연락처 읽기 권한의 현재 상태를 반환해요. `allowed`는 사용자가 연락처 읽기 권한을 허용한 상태예요. `denied`는 사용자가 연락처 읽기 권한을 거부한 상태예요. `notDetermined`는 연락처 읽기 권한 요청을 한 번도 하지 않은 상태예요.\n *\n * @returns {Promise<ContactResult>}\n * 연락처 목록과 페이지네이션 정보를 포함한 객체를 반환해요.\n * - `result`: 가져온 연락처 목록이에요.\n * - `nextOffset`: 다음 호출에 사용할 오프셋 값이에요. 더 가져올 연락처가 없으면 `null`이에요.\n * - `done`: 모든 연락처를 다 가져왔는지 여부를 나타내요. 모두 가져왔다면 `true`예요.\n *\n * @signature\n * ```typescript\n * function fetchContacts(options: {\n *   size: number;\n *   offset: number;\n *   query?: {\n *     contains?: string;\n *   };\n * }): Promise<ContactResult>;\n * ```\n *\n * @example\n * ### 특정 문자열이 포함된 연락처 목록 가져오기\n *\n * 연락처 목록을 가져오는 예제예요.\n * \"권한 확인하기\"버튼을 눌러서 현재 연락처 읽기 권한을 확인해요.\n * 사용자가 권한을 거부했거나 시스템에서 권한이 제한된 경우에는 [`FetchContactsPermissionError`](/react-native/reference/types/권한/FetchContactsPermissionError)를 반환해요.\n * \"권한 요청하기\"버튼을 눌러서 연락처 읽기 권한을 요청할 수 있어요.\n *\n * ```tsx\n * import { ContactEntity, fetchContacts, FetchContactsPermissionError } from '@apps-in-toss/framework';\n * import { useState } from 'react';\n * import { Alert, Button, Text, View } from 'react-native';\n *\n * // 특정 문자열을 포함한 연락처 목록을 가져와 화면에 표시하는 컴포넌트\n * function ContactsList() {\n *   const [contacts, setContacts] = useState<{\n *     result: ContactEntity[];\n *     nextOffset: number | null;\n *     done: boolean;\n *   }>({\n *     result: [],\n *     nextOffset: null,\n *     done: false,\n *   });\n *\n *   const handlePress = async () => {\n *     try {\n *       if (contacts.done) {\n *         console.log('모든 연락처를 가져왔어요.');\n *         return;\n *       }\n *\n *       const response = await fetchContacts({\n *         size: 10,\n *         offset: contacts.nextOffset ?? 0,\n *         query: { contains: '김' },\n *       });\n *       setContacts((prev) => ({\n *         result: [...prev.result, ...response.result],\n *         nextOffset: response.nextOffset,\n *         done: response.done,\n *       }));\n *     } catch (error) {\n *       if (error instanceof FetchContactsPermissionError) {\n *         // 연락처 읽기 권한 없음\n *       }\n *       console.error('연락처를 가져오는 데 실패했어요:', error);\n *     }\n *   };\n *\n *   return (\n *     <View>\n *       {contacts.result.map((contact, index) => (\n *         <Text key={index}>\n *           {contact.name}: {contact.phoneNumber}\n *         </Text>\n *       ))}\n *       <Button\n *         title={contacts.done ? '모든 연락처를 가져왔어요.' : '다음 연락처 가져오기'}\n *         disabled={contacts.done}\n *         onPress={handlePress}\n *       />\n *       <Button\n *         title=\"권한 확인하기\"\n *         onPress={async () => {\n *           const permission = await fetchContacts.getPermission();\n *           Alert.alert(permission);\n *         }}\n *       />\n *       <Button\n *         title=\"권한 요청하기\"\n *         onPress={async () => {\n *           const permission = await fetchContacts.openPermissionDialog();\n *           Alert.alert(permission);\n *         }}\n *       />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare const fetchContacts: PermissionFunctionWithDialog<FetchContacts>;\n\nexport {};\n"
  },
  {
    "identifier": "fetchAlbumPhotos",
    "dts": "/**\n * 앨범 사진을 조회할 때 사용하는 옵션 타입이에요.\n */\nexport interface FetchAlbumPhotosOptions {\n\t/** 가져올 사진의 최대 개수를 설정해요. 숫자를 입력하고 기본값은 10이에요. */\n\tmaxCount?: number;\n\t/** 사진의 최대 폭을 제한해요. 단위는 픽셀이고 기본값은 1024이에요. */\n\tmaxWidth?: number;\n\t/** 이미지를 base64 형식으로 반환할지 설정해요. 기본값은 `false`예요. */\n\tbase64?: boolean;\n}\n/**\n * 사진 조회 결과를 나타내는 타입이에요.\n */\nexport interface ImageResponse {\n\t/** 가져온 사진의 고유 ID예요. */\n\tid: string;\n\t/** 사진의 데이터 URI예요. `base64` 옵션이 `true`인 경우 Base64 문자열로 반환돼요. */\n\tdataUri: string;\n}\nexport type FetchAlbumPhotos = (options?: FetchAlbumPhotosOptions) => Promise<ImageResponse[]>;\ntype PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\nexport type GetPermissionFunction = () => Promise<PermissionStatus$1>;\nexport type PermissionFunctionWithDialog<T extends (...args: any[]) => any> = T & {\n\tgetPermission: GetPermissionFunction;\n\topenPermissionDialog: PermissionDialogFunction;\n};\n/**\n * @public\n * @category 사진\n * @name fetchAlbumPhotos\n * @description\n * 사용자의 앨범에서 사진 목록을 불러오는 함수예요.\n * 최대 개수와 해상도를 설정할 수 있고 갤러리 미리보기, 이미지 선택 기능 등에 활용할 수 있어요.\n *\n * @param options - 조회 옵션을 담은 객체예요.\n * @param {number} [options.maxCount=10] 가져올 사진의 최대 개수를 설정해요. 숫자로 입력하며 기본값은 10이에요.\n * @param {number} [options.maxWidth=1024] 사진의 최대 폭을 제한해요. 단위는 픽셀이며 기본값은 `1024`이에요.\n * @param {boolean} [options.base64=false] 이미지를 base64 형식으로 반환할지 설정해요. 기본값은 `false`예요.\n * @property [openPermissionDialog] - 사진첩 읽기 권한을 다시 요청하는 다이얼로그를 표시해요. 사용자는 \"허용\", \"한 번만 허용\", \"안하기\" 중 하나를 선택할 수 있어요. \"허용\"이나 \"한 번만 허용\"을 선택하면 `allowed`를 반환하고, \"안하기\"를 선택하면 `denied`를 반환해요.\n * @property [getPermission] - 사진첩 읽기 권한의 현재 상태를 반환해요. `allowed`는 사용자가 사진첩 읽기 권한을 허용한 상태예요. `denied`는 사용자가 사진첩 읽기 권한을 거부한 상태예요. `notDetermined`는 사진첩 읽기 권한 요청을 한 번도 하지 않은 상태예요.\n * @returns {Promise<ImageResponse[]>}\n * 앨범 사진의 고유 ID와 데이터 URI를 포함한 배열을 반환해요.\n *\n * @signature\n * ```typescript\n * function fetchAlbumPhotos(options: {\n *   maxCount: number;\n *   maxWidth: number;\n *   base64: boolean;\n * }): Promise<ImageResponse[]>;\n * ```\n *\n * @example\n * ### 사진의 최대 폭을 360px로 제한하여 가져오기\n *\n * 사진을 가져오는 예제예요.\n * \"권한 확인하기\"버튼을 눌러서 현재 사진첩 읽기 권한을 확인해요.\n * 사용자가 권한을 거부했거나 시스템에서 권한이 제한된 경우에는 [`FetchAlbumPhotosPermissionError`](/react-native/reference/types/권한/FetchAlbumPhotosPermissionError)를 반환해요.\n * \"권한 요청하기\"버튼을 눌러서 사진첩 읽기 권한을 요청할 수 있어요.\n *\n * ```tsx\n * import { fetchAlbumPhotos, FetchAlbumPhotosPermissionError, ImageResponse } from '@apps-in-toss/framework';\n * import { useState } from 'react';\n * import { Alert, Button, Image, View } from 'react-native';\n *\n * const base64 = true;\n *\n * // 앨범 사진 목록을 가져와 화면에 표시하는 컴포넌트\n * function AlbumPhotoList() {\n *   const [albumPhotos, setAlbumPhotos] = useState<ImageResponse[]>([]);\n *\n *   const handlePress = async () => {\n *     try {\n *       const response = await fetchAlbumPhotos({\n *         base64,\n *         maxWidth: 360,\n *       });\n *       setAlbumPhotos((prev) => [...prev, ...response]);\n *     } catch (error) {\n *       if (error instanceof FetchAlbumPhotosPermissionError) {\n *         // 앨범 읽기 권한 없음\n *       }\n *       console.error('앨범을 가져오는 데 실패했어요:', error);\n *     }\n *   };\n *\n *   return (\n *     <View>\n *       {albumPhotos.map((image) => {\n *         // base64 형식으로 반환된 이미지를 표시하려면 데이터 URL 스키마 Prefix를 붙여야해요.\n *         const imageUri = base64 ? 'data:image/jpeg;base64,' + image.dataUri : image.dataUri;\n *\n *         return <Image source={{ uri: imageUri }} key={image.id} />;\n *       })}\n *       <Button title=\"앨범 가져오기\" onPress={handlePress} />\n *       <Button\n *         title=\"권한 확인하기\"\n *         onPress={async () => {\n *           const permission = await fetchAlbumPhotos.getPermission();\n *           Alert.alert(permission);\n *         }}\n *       />\n *       <Button\n *         title=\"권한 요청하기\"\n *         onPress={async () => {\n *           const permission = await fetchAlbumPhotos.openPermissionDialog();\n *           Alert.alert(permission);\n *         }}\n *       />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare const fetchAlbumPhotos: PermissionFunctionWithDialog<FetchAlbumPhotos>;\n\nexport {};\n"
  },
  {
    "identifier": "getCurrentLocation",
    "dts": "declare enum Accuracy {\n\t/**\n\t * 오차범위 3KM 이내\n\t */\n\tLowest = 1,\n\t/**\n\t * 오차범위 1KM 이내\n\t */\n\tLow = 2,\n\t/**\n\t * 오차범위 몇 백미터 이내\n\t */\n\tBalanced = 3,\n\t/**\n\t * 오차범위 10M 이내\n\t */\n\tHigh = 4,\n\t/**\n\t * 가장 높은 정확도\n\t */\n\tHighest = 5,\n\t/**\n\t * 네비게이션을 위한 최고 정확도\n\t */\n\tBestForNavigation = 6\n}\nexport interface GetCurrentLocationOptions {\n\t/**\n\t * 위치 정보를 가져올 정확도 수준이에요.\n\t */\n\taccuracy: Accuracy;\n}\ninterface Location$1 {\n\t/**\n\t * Android에서만 지원하는 옵션이에요.\n\t *\n\t * - `FINE`: 정확한 위치\n\t * - `COARSE`: 대략적인 위치\n\t *\n\t * @see https://developer.android.com/codelabs/approximate-location\n\t */\n\taccessLocation?: \"FINE\" | \"COARSE\";\n\t/**\n\t * 위치가 업데이트된 시점의 유닉스 타임스탬프예요.\n\t */\n\ttimestamp: number;\n\t/**\n\t * @description 위치 정보를 나타내는 객체예요. 자세한 내용은 [LocationCoords](/react-native/reference/native-modules/Types/LocationCoords.html)을 참고해주세요.\n\t */\n\tcoords: LocationCoords;\n}\n/**\n * @public\n * @category 위치 정보\n * @name LocationCoords\n * @description 세부 위치 정보를 나타내는 객체예요.\n */\nexport interface LocationCoords {\n\t/**\n\t * 위도\n\t */\n\tlatitude: number;\n\t/**\n\t * 경도\n\t */\n\tlongitude: number;\n\t/**\n\t * 높이\n\t */\n\taltitude: number;\n\t/**\n\t * 위치 정확도\n\t */\n\taccuracy: number;\n\t/**\n\t * 고도 정확도\n\t */\n\taltitudeAccuracy: number;\n\t/**\n\t * 방향\n\t */\n\theading: number;\n}\nexport type GetCurrentLocation = (options: GetCurrentLocationOptions) => Promise<Location$1>;\ntype PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\nexport type GetPermissionFunction = () => Promise<PermissionStatus$1>;\nexport type PermissionFunctionWithDialog<T extends (...args: any[]) => any> = T & {\n\tgetPermission: GetPermissionFunction;\n\topenPermissionDialog: PermissionDialogFunction;\n};\n/**\n * @public\n * @category 위치 정보\n * @name getCurrentLocation\n * @description 디바이스의 현재 위치 정보를 가져오는 함수예요.\n * 위치 기반 서비스를 구현할 때 사용되고, 한 번만 호출되어 현재 위치를 즉시 반환해요.\n * 예를 들어 지도 앱에서 사용자의 현재 위치를 한 번만 가져올 때, 날씨 앱에서 사용자의 위치를 기반으로 기상 정보를 제공할 때, 매장 찾기 기능에서 사용자의 위치를 기준으로 가까운 매장을 검색할 때 사용하면 유용해요.\n *\n * @param {GetCurrentLocationOptions} options 위치 정보를 가져올 때 사용하는 옵션 객체예요.\n * @param {Accuracy} [options.accuracy] 위치 정보의 정확도 수준이에요. 정확도는 `Accuracy` 타입으로 설정돼요.\n * @property [openPermissionDialog] - 위치 정보 권한을 다시 요청하는 다이얼로그를 표시해요. 사용자는 \"허용\", \"한 번만 허용\", \"안하기\" 중 하나를 선택할 수 있어요. \"허용\"이나 \"한 번만 허용\"을 선택하면 `allowed`를 반환하고, \"안하기\"를 선택하면 `denied`를 반환해요.\n * @property [getPermission] - 위치 정보 권한의 현재 상태를 반환해요. `allowed`는 사용자가 위치 정보 권한을 허용한 상태예요. `denied`는 사용자가 위치 정보 권한을 거부한 상태예요. `notDetermined`는 위치 정보 권한 요청을 한 번도 하지 않은 상태예요.\n * @returns {Promise<Location>} 디바이스의 위치 정보가 담긴 객체를 반환해요. 자세한 내용은 [Location](/react-native/reference/native-modules/Types/Location.html)을 참고해주세요.\n *\n * @signature\n * ```typescript\n * function getCurrentLocation(options: {\n *   accuracy: Accuracy;\n * }): Promise<Location>;\n * ```\n *\n * @example\n * ### 디바이스의 현재 위치 정보 가져오기\n *\n * \"권한 확인하기\"버튼을 눌러서 현재 위치정보 권한을 확인해요.\n * 사용자가 권한을 거부했거나 시스템에서 권한이 제한된 경우에는 [`GetCurrentLocationPermissionError`](/react-native/reference/types/권한/GetCurrentLocationPermissionError)를 반환해요.\n * \"권한 요청하기\"버튼을 눌러서 위치정보 권한을 요청할 수 있어요.\n *\n * ```tsx\n * import { Accuracy, getCurrentLocation, Location } from '@apps-in-toss/framework';\n * import { useState } from 'react';\n * import { Alert, Button, Text, View } from 'react-native';\n *\n * // 현재 위치 정보를 가져와 화면에 표시하는 컴포넌트\n * function CurrentPosition() {\n *   const [position, setPosition] = useState<Location | null>(null);\n *\n *   const handlePress = async () => {\n *     try {\n *       const response = await getCurrentLocation({ accuracy: Accuracy.Balanced });\n *       setPosition(response);\n *     } catch (error) {\n *       console.error('위치 정보를 가져오는 데 실패했어요:', error);\n *     }\n *   };\n *\n *   return (\n *     <View>\n *       {position ? (\n *         <Text>\n *           위치: {position.coords.latitude}, {position.coords.longitude}\n *         </Text>\n *       ) : (\n *         <Text>위치 정보를 아직 가져오지 않았어요</Text>\n *       )}\n *       <Button title=\"현재 위치 정보 가져오기\" onPress={handlePress} />\n *       <Button\n *         title=\"권한 확인하기\"\n *         onPress={async () => {\n *           Alert.alert(await getCurrentLocation.getPermission());\n *         }}\n *       />\n *       <Button\n *         title=\"권한 요청하기\"\n *         onPress={async () => {\n *           Alert.alert(await getCurrentLocation.openPermissionDialog());\n *         }}\n *       />\n *     </View>\n *   );\n * }\n *\n * ```\n */\nexport declare const getCurrentLocation: PermissionFunctionWithDialog<GetCurrentLocation>;\n\nexport {};\n"
  },
  {
    "identifier": "openCamera",
    "dts": "/**\n * 사진 조회 결과를 나타내는 타입이에요.\n */\nexport interface ImageResponse {\n\t/** 가져온 사진의 고유 ID예요. */\n\tid: string;\n\t/** 사진의 데이터 URI예요. `base64` 옵션이 `true`인 경우 Base64 문자열로 반환돼요. */\n\tdataUri: string;\n}\nexport interface OpenCameraOptions {\n\t/**\n\t * 이미지를 Base64 형식으로 반환할지 여부를 나타내는 불리언 값이에요.\n\t *\n\t * 기본값: `false`.\n\t */\n\tbase64?: boolean;\n\t/**\n\t * 이미지의 최대 너비를 나타내는 숫자 값이에요.\n\t *\n\t * 기본값: `1024`.\n\t */\n\tmaxWidth?: number;\n}\nexport type OpenCamera = (options?: OpenCameraOptions) => Promise<ImageResponse>;\ntype PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\nexport type GetPermissionFunction = () => Promise<PermissionStatus$1>;\nexport type PermissionFunctionWithDialog<T extends (...args: any[]) => any> = T & {\n\tgetPermission: GetPermissionFunction;\n\topenPermissionDialog: PermissionDialogFunction;\n};\n/**\n * @public\n * @category 카메라\n * @name openCamera\n * @description 카메라를 실행해서 촬영된 이미지를 반환하는 함수예요.\n * @param {OpenCameraOptions} options - 카메라 실행 시 사용되는 옵션 객체예요.\n * @param {boolean} [options.base64=false] - 이미지를 Base64 형식으로 반환할지 여부를 나타내는 불리언 값이에요. 기본값은 `false`예요. `true`로 설정하면 `dataUri` 대신 Base64 인코딩된 문자열을 반환해요.\n * @param {number} [options.maxWidth=1024] - 이미지의 최대 너비를 나타내는 숫자 값이에요. 기본값은 `1024`예요.\n * @property [openPermissionDialog] - 카메라 접근 권한을 다시 요청하는 다이얼로그를 표시해요. 사용자는 \"허용\", \"한 번만 허용\", \"안하기\" 중 하나를 선택할 수 있어요. \"허용\"이나 \"한 번만 허용\"을 선택하면 `allowed`를 반환하고, \"안하기\"를 선택하면 `denied`를 반환해요.\n * @property [getPermission] - 카메라 접근 권한의 현재 상태를 반환해요. `allowed`는 사용자가 카메라 접근 권한을 허용한 상태예요. `denied`는 사용자가 카메라 접근 권한을 거부한 상태예요. `notDetermined`는 카메라 접근 권한 요청을 한 번도 하지 않은 상태예요.\n * @returns {Promise<ImageResponse>}\n * 촬영된 이미지 정보를 포함한 객체를 반환해요. 반환 객체의 구성은 다음과 같아요:\n * - `id`: 이미지의 고유 식별자예요.\n * - `dataUri`: 이미지 데이터를 표현하는 데이터 URI예요.\n *\n * @signature\n * ```typescript\n * function openCamera(options: {\n *   base64: boolean;\n *   maxWidth: number;\n * }): Promise<ImageResponse>;\n * ```\n *\n * @example\n * ### 카메라 실행 후 촬영된 사진 가져오기\n *\n * 카메라로 사진을 찍고 결과를 가져오는 예제예요.\n * 이 과정에서 현재 카메라 권한 상태를 확인할 수 있고, 권한이 없으면 권한을 요청해요.\n * 사용자가 권한을 거부했거나 시스템에서 권한이 제한된 경우에는 [`OpenCameraPermissionError`](/react-native/reference/types/권한/OpenCameraPermissionError)를 반환해요.\n *\n * ```tsx\n * import { ImageResponse, openCamera, OpenCameraPermissionError } from '@apps-in-toss/framework';\n * import { useState } from 'react';\n * import { Alert, Button, Image, Text, View } from 'react-native';\n *\n * const base64 = true;\n *\n * // 카메라를 실행하고 촬영된 이미지를 화면에 표시하는 컴포넌트\n * function Camera() {\n *   const [image, setImage] = useState<ImageResponse | null>(null);\n *\n *   const handlePress = async () => {\n *     try {\n *       const response = await openCamera({ base64 });\n *       setImage(response);\n *     } catch (error) {\n *       if (error instanceof OpenCameraPermissionError) {\n *         console.log('권한 에러');\n *       }\n *\n *       console.error('사진을 가져오는 데 실패했어요:', error);\n *     }\n *   };\n *\n *   // base64 형식으로 반환된 이미지를 표시하려면 데이터 URL 스키마 Prefix를 붙여야해요.\n *   const imageUri = base64 ? 'data:image/jpeg;base64,' + image?.dataUri : image?.dataUri;\n *\n *   return (\n *     <View>\n *       {image ? <Image source={{ uri: imageUri }} style={{ width: 200, height: 200 }} /> : <Text>사진이 없어요</Text>}\n *       <Button title=\"사진 촬영하기\" onPress={handlePress} />\n *       <Button\n *         title=\"권한 확인하기\"\n *         onPress={async () => {\n *           const permission = await openCamera.getPermission();\n *           Alert.alert(permission);\n *         }}\n *       />\n *\n *       <Button\n *         title=\"권한 요청하기\"\n *         onPress={async () => {\n *           const currentPermission = await openCamera.openPermissionDialog();\n *           Alert.alert(currentPermission);\n *         }}\n *       />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare const openCamera: PermissionFunctionWithDialog<OpenCamera>;\n\nexport {};\n"
  },
  {
    "identifier": "appLogin",
    "dts": "/**\n * @public\n * @category 로그인\n * @name appLogin\n * @description 토스 인증으로 로그인해요. 로그인이 완료되면 다시 토스 앱으로 이동해요.\n * @example\n *\n * ### 토스 인증을 통해 로그인을 하는 예제\n *\n * ```tsx\n * import { Button } from 'react-native';\n * import { appLogin } from '@apps-in-toss/framework';\n *\n * function Page() {\n *   const handleLogin = async () => {\n *     const { authorizationCode, referrer } = await appLogin();\n *\n *     // 획득한 인가 코드(`authorizationCode`)와 `referrer`를 서버로 전달해요.\n *   }\n *\n *   return <Button title=\"로그인\" onPress={handleLogin} />;\n * }\n * ```\n */\nexport declare function appLogin(): Promise<{\n\tauthorizationCode: string;\n\treferrer: \"DEFAULT\" | \"SANDBOX\";\n}>;\n\nexport {};\n"
  },
  {
    "identifier": "eventLog",
    "dts": "export type Primitive = string | number | boolean | null | undefined | symbol;\nexport interface EventLogParams {\n\tlog_name: string;\n\tlog_type: \"debug\" | \"info\" | \"warn\" | \"error\" | \"event\" | \"screen\" | \"impression\" | \"click\";\n\tparams: Record<string, Primitive>;\n}\n/**\n * @category 로깅\n * @kind function\n * @name eventLog\n * @description\n * 이벤트 로그를 기록하는 함수예요.\n *\n * 이 함수는 앱 내에서 발생하는 다양한 이벤트를 로깅하는 데 사용돼요. 디버깅, 정보 제공, 경고, 오류 등 다양한 유형의 로그를 기록할 수 있어요. 샌드박스 환경에서는 콘솔에 로그가 출력되고, 실제 환경에서는 로그 시스템에 기록돼요.\n *\n * @param {Object} params 로그 기록에 필요한 매개변수 객체예요.\n * @param {string} params.log_name 로그의 이름이에요.\n * @param {'debug' | 'info' | 'warn' | 'error' | 'event' | 'screen' | 'impression' | 'click'} params.log_type 로그의 유형이에요.\n * @param {Record<string, Primitive>} params.params 로그에 포함할 추가 매개변수 객체예요.\n *\n * @returns {Promise<void>} 로그 기록이 완료되면 해결되는 Promise예요.\n *\n * @example\n * ### 이벤트 로그 기록하기\n *\n * ```tsx\n * import { eventLog } from '@apps-in-toss/framework';\n *\n * function logUserAction() {\n *   eventLog({\n *     log_name: 'user_action',\n *     log_type: 'info',\n *     params: {\n *       action: 'button_click',\n *       screen: 'main',\n *       userId: 12345\n *     }\n *   });\n * }\n * ```\n */\nexport declare function eventLog(params: EventLogParams): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "getTossShareLink",
    "dts": "/**\n * @public\n * @category 공유\n * @kind function\n * @name getTossShareLink\n * @description\n * 사용자가 지정한 경로를 토스 앱에서 열 수 있는 공유 링크를 생성해요.\n *\n * 생성된 링크를 다른 사람과 공유하면:\n * - 토스 앱이 설치되어 있으면: 토스 앱이 실행되면서 지정한 경로로 이동해요.\n * - 토스 앱이 없으면: iOS는 앱스토어로, Android는 플레이스토어로 이동해요.\n *\n * @param path - 딥링크 경로예요. `intoss://`로 시작하는 문자열이어야 해요. (예: `intoss://my-app`, `intoss://my-app/detail?id=123`)\n * @param ogImageUrl - (선택) 공유 시 표시될 커스텀 OG 이미지 URL이에요. 최소 버전: Android 5.240.0, iOS 5.239.0\n * @returns {Promise<string>} 생성된 토스 공유 링크\n *\n * @example\n * ```tsx\n * import { share } from '@granite-js/react-native';\n * import { getTossShareLink } from '@apps-in-toss/framework';\n *\n * // 기본 사용법\n * const tossLink = await getTossShareLink('intoss://my-app');\n * await share({ message: tossLink });\n *\n * // 커스텀 OG 이미지와 함께 사용\n * const linkWithImage = await getTossShareLink(\n *   'intoss://my-app/event',\n *   'https://example.com/og-image.png'\n * );\n * await share({ message: linkWithImage });\n * ```\n */\nexport declare function getTossShareLink(path: string, ogImageUrl?: string): Promise<string>;\n\nexport {};\n"
  },
  {
    "identifier": "setDeviceOrientation",
    "dts": "/**\n * @public\n * @category 화면 제어\n * @kind function\n * @name setDeviceOrientation\n * @description\n * `setDeviceOrientation` 함수는 기기의 화면 방향을 설정하는 기능을 제공해요.\n * 이 기능은 특정 화면에서 가로 모드나 세로 모드를 강제로 지정해야 할 때 유용해요.\n *\n * `type` 옵션을 통해 원하는 화면 방향을 지정할 수 있어요. 특히, 이 함수는 앱 전체에 영향을 미치므로\n * 특정 화면에서만 사용하려면 화면을 벗어날 때 이전 상태로 복구하는 추가 작업이 필요해요.\n *\n * 예를 들어, 동영상 감상 화면에서는 가로 모드를 강제하고, 화면을 떠날 때 설정을 복구해서\n * 다른 화면들의 방향 설정에 영향을 주지 않도록 할 수 있어요.\n *\n * @param {object} options 화면 방향 설정 값이에요.\n * @param {string} options.type 화면 방향을 지정하는 옵션이에요.\n * 'portrait' | 'landscape' 중 하나를 선택할 수 있어요.\n *\n * @returns {Promise<void>} 화면 방향 설정이 완료되면 해결되는 Promise를 반환해요.\n *\n * @example\n * ### 화면 방향 설정하기\n *\n * ```tsx\n * import { Button } from 'react-native';\n * import { setDeviceOrientation } from '@apps-in-toss/framework';\n *\n * function SetDeviceOrientation() {\n *   return (\n *     <Button\n *       title=\"가로 모드로 변경\"\n *       onPress={() => {\n *         setDeviceOrientation({ type: 'landscape' });\n *       }}\n *     />\n *   );\n * }\n * ```\n *\n * ### 화면 방향 복구하기\n * 특정 화면을 벗어날 때 이전 상태로 복구하려면 다음과 같이 `useEffect`를 사용하세요.\n *\n * ```tsx\n * import { useEffect } from 'react';\n * import { setDeviceOrientation } from '@apps-in-toss/framework';\n *\n * function VideoScreen() {\n *   useEffect(() => {\n *     setDeviceOrientation({ type: 'landscape' });\n *\n *     return () => {\n *       setDeviceOrientation({ type: 'portrait' }); // 설정을 이전 상태로 복구해요.\n *     };\n *   }, []);\n *\n *   return <Text>동영상을 감상하는 화면</Text>;\n * }\n * ```\n */\nexport declare function setDeviceOrientation(options: {\n\ttype: \"portrait\" | \"landscape\";\n}): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "checkoutPayment",
    "dts": "/**\n * @public\n * @category 토스페이\n * @name CheckoutPaymentOptions\n * @description 토스페이 결제창을 띄울 때 필요한 옵션이에요.\n * @property {string} payToken 결제 토큰이에요.\n */\nexport interface CheckoutPaymentOptions {\n\t/**\n\t * 결제 토큰이에요.\n\t */\n\tpayToken: string;\n}\n/**\n * @public\n * @category 토스페이\n * @name CheckoutPaymentResult\n * @description 토스페이 결제창에서 사용자가 인증에 성공했는지 여부예요.\n * @property {boolean} success 인증이 성공했는지 여부예요.\n * @property {string} [reason] 인증이 실패했을 경우의 이유예요.\n */\nexport interface CheckoutPaymentResult {\n\t/**\n\t * 인증이 성공했는지 여부예요.\n\t */\n\tsuccess: boolean;\n\t/**\n\t * 인증이 실패했을 경우의 이유예요.\n\t */\n\treason?: string;\n}\n/**\n * @public\n * @category 토스페이\n * @name checkoutPayment\n * @description 토스페이 결제창을 띄우고, 사용자 인증을 수행해요. 인증이 완료되면 성공 여부를 반환해요.\n *\n * 이 함수는 결제창을 통해 사용자 인증만 해요. 실제 결제 처리는 인증 성공 후 서버에서 별도로 해야 해요.\n *\n * @param {CheckoutPaymentOptions} options 결제창을 띄울 때 필요한 옵션이에요.\n * @returns {Promise<CheckoutPaymentResult>} 인증 성공 여부를 포함한 결과를 반환해요.\n *\n * @example\n *\n * ### 토스페이 결제창 띄우고 인증 처리하기\n *\n * ```tsx\n * import { TossPay } from '@apps-in-toss/framework';\n *\n * async function handlePayment() {\n *   try {\n *     // 실제 구현 시 결제 생성 역할을 하는 API 엔드포인트로 대체해주세요.\n *     const { payToken } = await fetch('/my-api/payment/create').then(res => res.json());\n *\n *     const { success, reason } = await TossPay.checkoutPayment({ payToken });\n *\n *     if (success) {\n *       // 실제 구현 시 결제를 실행하는 API 엔드포인트로 대체해주세요.\n *       await fetch('/my-api/payment/execute', {\n *         method: 'POST',\n *         body: JSON.stringify({ payToken }),\n *         headers: { 'Content-Type': 'application/json' },\n *       });\n *     } else {\n *       console.log('인증 실패:', reason);\n *     }\n *   } catch (error) {\n *     console.error('결제 인증 중 오류가 발생했어요:', error);\n *   }\n * }\n * ```\n */\nexport declare function checkoutPayment(options: CheckoutPaymentOptions): Promise<CheckoutPaymentResult>;\n\nexport {};\n"
  },
  {
    "identifier": "saveBase64Data",
    "dts": "export interface SaveBase64DataParams {\n\tdata: string;\n\tfileName: string;\n\tmimeType: string;\n}\n/**\n * @public\n * @category 데이터\n * @name saveBase64Data\n * @description 문자열로 인코딩된 Base64 데이터를 지정한 파일 이름과 MIME 타입으로 사용자 기기에 저장해요. 이미지, 텍스트, PDF 등 다양한 형식의 데이터를 저장할 수 있어요.\n * @param {SaveBase64DataParams} params - 저장할 데이터와 파일 정보를 담은 객체예요.\n * @param {string} params.data - Base64 형식으로 인코딩된 데이터 문자열이에요.\n * @param {string} params.fileName - 저장할 파일 이름이에요. 확장자도 같이 붙여줘야해요. 예를 들어, 'example.png'로 저장할 수 있어요.\n * @param {string} params.mimeType - 저장할 파일의 MIME 타입이에요. 예를 들어 'image/png' 로 지정하면 이미지, 'application/pdf'는 PDF 파일이에요. 자세한 내용은 [MIME 문서](https://developer.mozilla.org/ko/docs/Web/HTTP/Guides/MIME_types)를 참고해주세요.\n *\n * @example\n * ### Base64 이미지 데이터를 사용자 기기에 저장하기\n *\n * ```tsx\n * import { Button } from 'react-native';\n * import { saveBase64Data } from '@apps-in-toss/framework';\n *\n * // '저장' 버튼을 누르면 이미지가 사용자 기기에 저장돼요.\n * function SaveButton() {\n *   const handleSave = async () => {\n *     try {\n *       await saveBase64Data({\n *         data: 'iVBORw0KGgo...',\n *         fileName: 'some-photo.png',\n *         mimeType: 'image/png',\n *       });\n *     } catch (error) {\n *       console.error('데이터 저장에 실패했어요:', error);\n *     }\n *   };\n *\n *   return <Button title=\"저장\" onPress={handleSave} />;\n * }\n * ```\n */\nexport declare function saveBase64Data(params: SaveBase64DataParams): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "appsInTossSignTossCert",
    "dts": "export interface AppsInTossSignTossCertParams {\n\ttxId: string;\n\tskipConfirmDoc?: boolean;\n}\n/**\n * @public\n * @category 토스인증\n * @name appsInTossSignTossCert\n * @description 토스 인증서를 사용해 서명하는 기능을 제공해요. 이 함수를 사용하면 앱인토스에서 제공하는 인증서를 활용해 서명을 할 수 있어요.\n *\n * @param {AppsInTossSignTossCertParams} params - 서명에 필요한 파라미터를 포함하는 객체예요.\n * @param {string} params.txId - 토스인증서를 사용한 본인확인이나 간편인증, 전자서명에서 사용하는 Transaction Id예요.\n * @param {boolean} params.skipConfirmDoc - (선택) 토스 원터치 인증방식을 사용하기 위한 옵션이예요. true 설정 시 최소 버전: Android 5.236.0, iOS 5.236.0 (default: false)\n *\n * @example\n * ```tsx\n * import { appsInTossSignTossCert } from '@apps-in-toss/framework';\n *\n *  // 서명에 필요한 파라미터를 정의해요.\n *  const params = {\n *    txId: \"f2e1a6df...\"\n *  };\n *\n * appsInTossSignTossCert(params)\n *   .then(() => {\n *     console.log('서명 작업이 성공적으로 완료되었어요.');\n *   })\n *   .catch((error) => {\n *     console.error('서명 작업 중 에러가 발생했어요:', error);\n *   });\n * ```\n */\nexport declare function appsInTossSignTossCert(params: AppsInTossSignTossCertParams): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "getGameCenterGameProfile",
    "dts": "/**\n * @category 게임센터\n * @name GameCenterGameProfileResponse\n * @description 토스게임센터 프로필을 가져온 결과 타입이에요.\n * 앱에 프로필이 없는 경우, `statusCode`가 `'PROFILE_NOT_FOUND'`이고 다른 정보는 없어요.\n * 프로필이 있는 경우 `statusCode`가 `'SUCCESS'`이고, 닉네임과 프로필 이미지 주소가 함께 제공돼요.\n * @property {string} statusCode 프로필 조회 결과 상태예요. `'SUCCESS'` 또는 `'PROFILE_NOT_FOUND'` 중 하나예요.\n * @property {string} [nickname] 프로필 닉네임이에요. `statusCode`가 `'SUCCESS'`일 때만 있어요.\n * @property {string} [profileImageUri] 프로필 이미지 URL이에요. `statusCode`가 `'SUCCESS'`일 때만 있어요.\n */\nexport type GameCenterGameProfileResponse = {\n\tstatusCode: \"PROFILE_NOT_FOUND\";\n} | {\n\tstatusCode: \"SUCCESS\";\n\tnickname: string;\n\tprofileImageUri: string;\n};\n/**\n * @category 게임센터\n * @name getGameCenterGameProfile\n * @description 토스게임센터 프로필 정보를 가져와요.\n * 사용자가 프로필을 만들지 않았다면 `statusCode`가 `'PROFILE_NOT_FOUND'`인 응답이 반환돼요.\n * 앱 버전이 최소 지원 버전(안드로이드 5.221.0, iOS 5.221.0)보다 낮으면 `undefined`를 반환해요.\n * @returns {Promise<GameCenterGameProfileResponse | undefined>} 프로필 정보 또는 `undefined`를 반환해요.\n *\n * @example\n * ### 게임센터 프로필 가져오기\n * ```tsx\n * import { getGameCenterGameProfile } from './getGameCenterGameProfile';\n * import { useState } from 'react';\n * import { View, Button } from 'react-native';\n *\n * function GameProfile() {\n *   const [profile, setProfile] = useState<GameCenterGameProfileResponse | null>(null);\n *\n *   const handlePress = async () => {\n *     try {\n *       const result = await getGameCenterGameProfile();\n *       if (result) {\n *         setProfile(result);\n *       }\n *     } catch (error) {\n *       console.error('게임센터 프로필 가져오기에 실패했어요.', error);\n *     }\n *   };\n *\n *   return (\n *     <View>\n *       <Button title=\"게임센터 프로필 가져오기\" onPress={handlePress} />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare function getGameCenterGameProfile(): Promise<GameCenterGameProfileResponse | undefined>;\n\nexport {};\n"
  },
  {
    "identifier": "openGameCenterLeaderboard",
    "dts": "/**\n * @public\n * @category 게임센터\n * @name openGameCenterLeaderboard\n * @description 게임센터 리더보드 웹뷰를 열어요.\n * 앱 버전이 최소 지원 버전(`5.221.0`)보다 낮으면 아무 동작도 하지 않고 `undefined`를 반환해요.\n * 게임센터를 사용하는 사용자는 반드시 최소 지원 버전 이상이어야 게임을 실행할 수 있어요.\n * @returns 리더보드 웹뷰를 호출해요. 앱 버전이 낮으면 아무 동작도 하지 않고 `undefined`를 반환해요.\n *\n * @example\n * import { Button } from 'react-native';\n * import { openGameCenterLeaderboard } from '@apps-in-toss/framework';\n *\n * // '리더보드' 버튼을 누르면 게임센터 리더보드 웹뷰가 열려요.\n * function LeaderboardButton() {\n *   const onPress = () => {\n *     openGameCenterLeaderboard();\n *   };\n *\n *   return <Button title=\"리더보드 웹뷰 호출\" onPress={onPress} />;\n * }\n */\nexport declare function openGameCenterLeaderboard(): Promise<void>;\n\nexport {};\n"
  },
  {
    "identifier": "submitGameCenterLeaderBoardScore",
    "dts": "/**\n * @public\n * @category 게임센터\n * @name SubmitGameCenterLeaderBoardScoreResponse\n * @description\n * 토스게임센터 리더보드에 점수를 제출한 결과 정보를 담아서 반환해요. 반환된 정보를 사용해서 점수 제출 결과에 따라 적절한 에러 처리를 할 수 있어요.\n * @property {'SUCCESS' | 'LEADERBOARD_NOT_FOUND' | 'PROFILE_NOT_FOUND' | 'UNPARSABLE_SCORE'} statusCode\n * 점수 제출 결과를 나타내는 상태 코드예요.\n * - `'SUCCESS'`: 점수 제출이 성공했어요.\n * - `'LEADERBOARD_NOT_FOUND'`: `gameId`에 해당하는 리더보드를 찾을 수 없어요.\n * - `'PROFILE_NOT_FOUND'`: 사용자의 프로필이 없어요.\n * - `'UNPARSABLE_SCORE'`: 점수를 해석할 수 없어요. 점수는 실수(float) 형태의 문자열로 전달해야 해요.\n */\nexport interface SubmitGameCenterLeaderBoardScoreResponse {\n\tstatusCode: \"SUCCESS\" | \"LEADERBOARD_NOT_FOUND\" | \"PROFILE_NOT_FOUND\" | \"UNPARSABLE_SCORE\";\n}\n/**\n * @public\n * @category 게임센터\n * @name submitGameCenterLeaderBoardScore\n * @description\n * 사용자의 게임 점수를 토스게임센터 리더보드에 제출해요. 이 기능으로 사용자의 점수를 공식 리더보드에 기록하고 다른 사용자와 비교할 수 있어요.\n * @param {string} params.score\n * 제출할 게임 점수예요. 실수 형태의 숫자를 문자열로 전달해야 해요. 예를들어 `\"123.45\"` 또는 `\"9999\"` 예요.\n * @returns {Promise<SubmitGameCenterLeaderBoardScoreResponse | undefined>}\n * 점수 제출 결과를 반환해요. 앱 버전이 최소 지원 버전보다 낮으면 아무 동작도 하지 않고 `undefined`를 반환해요.\n *\n * @example\n * ### 게임 점수를 토스게임센터 리더보드에 제출하기\n * ```tsx\n * import { Button } from 'react-native';\n * import { submitGameCenterLeaderBoardScore } from '@apps-in-toss/framework';\n *\n * function GameCenterLeaderBoardScoreSubmitButton() {\n *   async function handlePress() {\n *     try {\n *       const result = await submitGameCenterLeaderBoardScore({ score: '123.45' });\n *\n *       if (!result) {\n *         console.warn('지원하지 않는 앱 버전이에요.');\n *         return;\n *       }\n *\n *       if (result.statusCode === 'SUCCESS') {\n *         console.log('점수 제출 성공!');\n *       } else {\n *         console.error('점수 제출 실패:', result.statusCode);\n *       }\n *     } catch (error) {\n *       console.error('점수 제출 중 오류가 발생했어요.', error);\n *     }\n *   }\n *\n *   return (\n *     <Button onPress={handlePress}>점수 제출하기</Button>\n *   );\n * }\n * ```\n */\nexport declare function submitGameCenterLeaderBoardScore(params: {\n\tscore: string;\n}): Promise<SubmitGameCenterLeaderBoardScoreResponse | undefined>;\n\nexport {};\n"
  },
  {
    "identifier": "getUserKeyForGame",
    "dts": "export interface GetUserKeyForGameSuccessResponse {\n\thash: string;\n\ttype: \"HASH\";\n}\nexport interface GetUserKeyForGameErrorResponse {\n\ttype: \"NOT_AVAILABLE\";\n}\nexport type GetUserKeyForGameResponse = GetUserKeyForGameSuccessResponse | GetUserKeyForGameErrorResponse;\n/**\n * @public\n * @category 게임\n * @name getUserKeyForGame\n * @description\n * 게임 카테고리 미니앱에서 사용자의 고유 키를 가져와요. 이 키를 사용해서 사용자를 식별하고 게임 데이터를 관리할 수 있어요.\n * 게임 카테고리가 아닌 미니앱에서 호출하면 `'INVALID_CATEGORY'`를 반환해요.\n * @returns {Promise<GetUserKeyForGameSuccessResponse | 'INVALID_CATEGORY' | 'ERROR' | undefined>}\n * 사용자 키 조회 결과를 반환해요.\n * - `GetUserKeyForGameSuccessResponse`: 사용자 키 조회에 성공했어요. `{ type: 'HASH', hash: string }` 형태로 반환돼요.\n * - `'INVALID_CATEGORY'`: 게임 카테고리가 아닌 미니앱에서 호출했어요.\n * - `'ERROR'`: 알 수 없는 오류가 발생했어요.\n * - `undefined`: 앱 버전이 최소 지원 버전보다 낮아요.\n *\n * @example\n * ```tsx\n * // react-native\n * import { Button } from 'react-native';\n * import { getUserKeyForGame } from '@apps-in-toss/framework';\n *\n * function GameUserKeyButton() {\n *   async function handlePress() {\n *       const result = await getUserKeyForGame();\n *\n *       if (!result) {\n *         console.warn('지원하지 않는 앱 버전이에요.');\n *         return;\n *       }\n *\n *       if (result === 'INVALID_CATEGORY') {\n *         console.error('게임 카테고리가 아닌 미니앱이에요.');\n *         return;\n *       }\n *\n *       if (result === 'ERROR') {\n *         console.error('사용자 키 조회 중 오류가 발생했어요.');\n *         return;\n *       }\n *\n *       if (result.type === 'HASH') {\n *         console.log('사용자 키:', result.hash);\n *         // 여기에서 사용자 키를 사용해 게임 데이터를 관리할 수 있어요.\n *       }\n *   }\n *\n *   return (\n *     <Button onPress={handlePress} title=\"유저 키 가져오기\" />\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // webview\n * import { getUserKeyForGame } from '@apps-in-toss/web-framework';\n *\n * function GameUserKeyButton() {\n *   async function handleClick() {\n *       const result = await getUserKeyForGame();\n *\n *       if (!result) {\n *         console.warn('지원하지 않는 앱 버전이에요.');\n *         return;\n *       }\n *\n *       if (result === 'INVALID_CATEGORY') {\n *         console.error('게임 카테고리가 아닌 미니앱이에요.');\n *         return;\n *       }\n *\n *       if (result === 'ERROR') {\n *         console.error('사용자 키 조회 중 오류가 발생했어요.');\n *         return;\n *       }\n *\n *       if (result.type === 'HASH') {\n *         console.log('사용자 키:', result.hash);\n *         // 여기에서 사용자 키를 사용해 게임 데이터를 관리할 수 있어요.\n *       }\n *   }\n *\n *   return (\n *     <button onClick={handleClick}>유저 키 가져오기</button>\n *   );\n * }\n * ```\n */\nexport declare function getUserKeyForGame(): Promise<GetUserKeyForGameSuccessResponse | \"INVALID_CATEGORY\" | \"ERROR\" | undefined>;\n\nexport {};\n"
  },
  {
    "identifier": "getIsTossLoginIntegratedService",
    "dts": "/**\n * @public\n * @category 토스 로그인\n * @name getIsTossLoginIntegratedService\n * @description\n * 유저가 토스 로그인을 연동했는지 여부를 확인해요.\n * 기존 토스 로그인 사용자를 찾아서 게임 식별자로 전환하는 마이그레이션을 할 때 사용할 수 있어요.\n * @returns {Promise<boolean | undefined>}\n * 토스 로그인이 연동된 유저인지 여부를 반환해요.\n * - `true`: 토스 로그인이 연동된 유저에요.\n * - `false`: 토스 로그인이 연동되지 않은 유저에요.\n * - `undefined`: 앱 버전이 최소 지원 버전보다 낮아요.\n * @throw {message: \"oauth2ClientId 설정이 필요합니다.\"} - 토스 로그인을 사용하지 않는 미니앱에서 호출했을 때 발생해요.\n * @example\n * ```tsx\n * // react-native\n * import { Button } from 'react-native';\n * import { getIsTossLoginIntegratedService } from '@apps-in-toss/framework';\n *\n * function GetIsTossLoginIntegratedServiceButton() {\n *   async function handlePress() {\n *     try {\n *       const result = await getIsTossLoginIntegratedService();\n *\n *       if (result === undefined) {\n *         console.warn('지원하지 않는 앱 버전이에요.');\n *         return;\n *       }\n *       if (result === true) {\n *         console.log('토스 로그인이 연동된 유저에요.');\n *         // 여기에서 토스 로그인 연동 유저에 대한 처리를 할 수 있어요.\n *       }\n *       if (result === false) {\n *         console.log('토스 로그인이 연동되지 않은 유저에요.');\n *         // 여기에서 토스 로그인 연동 유저가 아닌 경우에 대한 처리를 할 수 있어요.\n *       }\n *     } catch (error) {\n *       console.error(error);\n *     }\n *   }\n *\n *   return (\n *     <Button onPress={handlePress} title=\"토스 로그인 통합 서비스 여부 확인\" />\n *   );\n * }\n * ```\n */\nexport declare function getIsTossLoginIntegratedService(): Promise<boolean | undefined>;\n\nexport {};\n"
  },
  {
    "identifier": "grantPromotionRewardForGame",
    "dts": "export interface GrantPromotionRewardForGameSuccessResponse {\n\tkey: string;\n}\nexport interface GrantPromotionRewardForGameErrorResponse {\n\tcode: string;\n\t[key: string]: any;\n}\nexport interface GrantPromotionRewardForGameErrorResult {\n\terrorCode: string;\n\tmessage: string;\n}\nexport type GrantPromotionRewardForGameResponse = GrantPromotionRewardForGameSuccessResponse | GrantPromotionRewardForGameErrorResponse;\nexport type GrantPromotionRewardForGameResult = GrantPromotionRewardForGameResponse | GrantPromotionRewardForGameErrorResult | \"ERROR\" | undefined;\n/**\n * @public\n * @category 게임\n * @name grantPromotionRewardForGame\n * @description\n * 이 함수를 사용하면 게임 카테고리 미니앱에서 프로모션 코드를 사용해서 유저에게 리워드를 지급할 수 있어요.\n * 게임 카테고리가 아닌 미니앱에서 호출할 수 없어요.\n * @param {{ params: { promotionCode: string; amount: number } }} params - 포인트를 지급하기 위해 필요한 정보예요.\n * @param {string} params.promotionCode - 프로모션 코드예요.\n * @param {number} params.amount - 지급할 포인트 금액이에요.\n * @returns {Promise<{ key: string } | { errorCode: string; message: string } | 'ERROR' | undefined>}\n * 포인트 지급 결과를 반환해요.\n * - `{ key: string }`: 포인트 지급에 성공했어요. key는 리워드 키를 의미해요.\n * - `{ errorCode: string, message: string }`: 포인트 지급에 실패했어요. 에러 코드는 다음과 같아요.\n *   - `\"40000\"`: 게임이 아닌 미니앱에서 호출했을 때\n *   - `\"4100\"`: 프로모션 정보를 찾을 수 없을 때\n *   - `\"4104\"`: 프로모션이 중지되었을 때\n *   - `\"4105\"`: 프로모션이 종료되었을 때\n *   - `\"4108\"`: 프로모션이 승인되지 않았을 때\n *   - `\"4109\"`: 프로모션이 실행중이 아닐 때\n *   - `\"4110\"`: 리워드를 지급/회수할 수 없을 때\n *   - `\"4112\"`: 프로모션 머니가 부족할 때\n *   - `\"4113\"`: 이미 지급/회수된 내역일 때\n *   - `\"4114\"`: 프로모션에 설정된 1회 지급 금액을 초과할 때\n * - `'ERROR'`: 알 수 없는 오류가 발생했어요.\n * - `undefined`: 앱 버전이 최소 지원 버전보다 낮아요.\n * @example\n * ```tsx\n * // react-native\n * import { Button } from 'react-native';\n * import { grantPromotionRewardForGame } from '@apps-in-toss/framework';\n *\n * function GrantRewardButton() {\n *   async function handlePress() {\n *       const result = await grantPromotionRewardForGame({\n *         params: {\n *           promotionCode: 'GAME_EVENT_2024',\n *           amount: 1000,\n *         },\n *       });\n *\n *       if (!result) {\n *         console.warn('지원하지 않는 앱 버전이에요.');\n *         return;\n *       }\n *\n *       if (result === 'ERROR') {\n *         console.error('포인트 지급 중 알 수 없는 오류가 발생했어요.');\n *         return;\n *       }\n *\n *       if ('key' in result) {\n *         console.log('포인트 지급 성공!', result.key);\n *       } else if ('errorCode' in result) {\n *         console.error('포인트 지급 실패:', result.errorCode, result.message);\n *       }\n *   }\n *\n *   return <Button onPress={handlePress} title=\"포인트 지급하기\" />;\n * }\n * ```\n *\n * @example\n * ```tsx\n * // webview\n * import { grantPromotionRewardForGame } from '@apps-in-toss/web-framework';\n *\n * function GrantRewardButton() {\n *   async function handleClick() {\n *       const result = await grantPromotionRewardForGame({\n *         params: {\n *           promotionCode: 'GAME_EVENT_2024',\n *           amount: 1000,\n *         },\n *       });\n *\n *       if (!result) {\n *         console.warn('지원하지 않는 앱 버전이에요.');\n *         return;\n *       }\n *\n *       if (result === 'ERROR') {\n *         console.error('포인트 지급 중 알 수 없는 오류가 발생했어요.');\n *         return;\n *       }\n *\n *       if ('key' in result) {\n *         console.log('포인트 지급 성공!', result.key);\n *       } else if ('errorCode' in result) {\n *         console.error('포인트 지급 실패:', result.errorCode, result.message);\n *       }\n *   }\n *\n *   return (\n *     <button onClick={handleClick}>포인트 지급하기</button>\n *   );\n * }\n * ```\n */\nexport declare function grantPromotionRewardForGame({ params, }: {\n\tparams: {\n\t\tpromotionCode: string;\n\t\tamount: number;\n\t};\n}): Promise<GrantPromotionRewardForGameResult>;\n\nexport {};\n"
  },
  {
    "identifier": "getLocale",
    "dts": "/**\n * @public\n * @category 언어\n * @kind function\n * @name getLocale\n * @description\n * 사용자의 로케일(locale) 정보를 반환해요. 네이티브 모듈에서 로케일 정보를 가져올 수 없을 때는 기본값으로 'ko-KR'을 반환합니다. 앱의 현지화 및 언어 설정과 관련된 기능을 구현할 때 사용하세요.\n *\n * @returns {string} 사용자의 로케일 정보를 반환해요.\n *\n * @example\n * ### 현재 사용자의 로케일 정보 가져오기\n *\n * ```tsx\n * import { getLocale } from '@apps-in-toss/native-modules';\n * import { Text } from 'react-native';\n *\n * function MyPage() {\n *  const locale = getLocale();\n *\n *  return (\n *    <Text>사용자의 로케일 정보: {locale}</Text>\n *  )\n * }\n *\n * ```\n */\nexport declare function getLocale(): string;\n\nexport {};\n"
  },
  {
    "identifier": "getSchemeUri",
    "dts": "/**\n * @public\n * @name getSchemeUri\n * @category 환경 확인\n * @kind function\n * @description 처음에 화면에 진입한 스킴 값이에요. 페이지 이동으로 인한 URI 변경은 반영되지 않아요.\n * @returns {string} 처음에 화면에 진입한 스킴 값을 반환해요.\n *\n * @example\n * ### 처음 진입한 스킴 값 가져오기\n *\n * ```tsx\n * import { getSchemeUri } from '@apps-in-toss/native-modules';\n * import { Text } from 'react-native';\n *\n * function MyPage() {\n *  const schemeUri = getSchemeUri();\n *\n *  return <Text>처음에 화면에 진입한 스킴 값: {schemeUri}</Text>\n * }\n * ```\n */\nexport declare function getSchemeUri(): string;\n\nexport {};\n"
  },
  {
    "identifier": "getPlatformOS",
    "dts": "/**\n * @public\n * @kind function\n * @category 환경 확인\n *\n * @name getPlatformOS\n * @signature\n * ```typescript\n * function getPlatformOS(): 'ios' | 'android';\n * ```\n *\n * @description\n * 현재 실행 중인 플랫폼을 확인하는 함수예요.\n * 이 함수는 `react-native`의 [`Platform.OS`](https://reactnative.dev/docs/0.72/platform#os) 값을 기반으로 동작하며, `ios` 또는 `android` 중 하나의 문자열을 반환해요.\n *\n * @returns {'ios' | 'android'} 현재 실행 중인 플랫폼\n *\n * @example\n *\n * ### 현재 실행중인 OS 플랫폼 확인하기\n *\n * ```tsx\n * import { getPlatformOS } from '@apps-in-toss/native-modules';\n * import { Text } 'react-native';\n *\n * function Page() {\n *   const platform = getPlatformOS();\n *\n *   return <Text>현재 플랫폼: {platform}</Text>;\n * }\n * ```\n */\nexport declare function getPlatformOS(): \"ios\" | \"android\";\n\nexport {};\n"
  },
  {
    "identifier": "getOperationalEnvironment",
    "dts": "/**\n * @public\n * @category 환경 확인\n * @kind function\n * @name getOperationalEnvironment\n * @description\n * 현재 실행 중인 앱의 운영 환경을 확인해요.\n * 토스 앱에서 실행 중이라면 `'toss'`, 샌드박스 환경에서 실행 중이라면 `'sandbox'`를 반환해요.\n *\n * 운영 환경은 앱이 실행되는 컨텍스트를 의미하며, 특정 기능의 사용 가능 여부를 판단하는 데 활용할 수 있어요.\n *\n * @returns {'toss' | 'sandbox'}\n * 현재 운영 환경을 나타내는 문자열이에요.\n * - `'toss'`: 토스 앱에서 실행 중이에요.\n * - `'sandbox'`: 샌드박스 환경에서 실행 중이에요.\n *\n * @example\n * ### 현재 운영 환경 확인하기\n *\n * ```tsx\n * import { getOperationalEnvironment } from '@apps-in-toss/framework';\n * import { Text } from 'react-native';\n *\n * function EnvironmentInfo() {\n *   const environment = getOperationalEnvironment();\n *\n *   return (\n *     <Text>현재 운영 환경: {environment}</Text>\n *   );\n * }\n * ```\n */\nexport declare function getOperationalEnvironment(): \"toss\" | \"sandbox\";\n\nexport {};\n"
  },
  {
    "identifier": "getTossAppVersion",
    "dts": "/**\n * @public\n * @category 환경 확인\n * @name getTossAppVersion\n * @description 토스 앱 버전을 가져옵니다. 예를 들어, `5.206.0`과 같은 형태로 반환돼요. 토스 앱 버전을 로그로 남기거나, 특정 기능이 특정 버전 이상에서만 실행될 때 사용돼요.\n * @signature\n * ```typescript\n * function getTossAppVersion(): string\n * ```\n *\n * @returns {string} 토스 앱 버전\n *\n * @example\n *\n *\n * ### 토스 앱 버전 확인하기\n *\n * ```tsx\n * import { getTossAppVersion } from '@apps-in-toss/framework';\n * import { Text } from 'react-native';\n *\n * export function TossAppVersionPage() {\n *  return (\n *   <Text>{getTossAppVersion()}</Text>\n *  )\n * }\n * ```\n */\nexport declare function getTossAppVersion(): string;\n\nexport {};\n"
  },
  {
    "identifier": "getDeviceId",
    "dts": "/**\n * @public\n * @category 환경 확인\n * @kind function\n * @name getDeviceId\n * @description\n * 사용 중인 기기의 고유 식별자를 문자열로 반환해요.\n *\n * 이 함수는 현재 사용 중인 기기의 고유 식별자를 문자열로 반환해요. 기기별로 설정이나 데이터를 저장하거나 사용자의 기기를 식별해서 로그를 기록하고 분석하는 데 사용할 수 있어요. 같은 사용자의 여러 기기를 구분하는 데도 유용해요.\n *\n * @returns {string} 기기의 고유 식별자를 나타내는 문자열이에요.\n *\n * @example\n * ### 기기 고유 식별자 가져오기\n *\n * ```tsx\n * import { getDeviceId } from '@apps-in-toss/framework';\n * import { Text } from 'react-native';\n *\n * function MyPage() {\n *   const id = getDeviceId();\n *\n *   return (\n *     <Text>사용자의 기기 고유 식별자: {id}</Text>\n *   );\n * }\n * ```\n */\nexport declare function getDeviceId(): string;\n\nexport {};\n"
  },
  {
    "identifier": "contactsViral",
    "dts": "/**\n * @public\n * @category 친구초대\n * @name RewardFromContactsViralEvent\n * @description 친구에게 공유하기를 완료했을 때 지급할 리워드 정보를 담는 타입이에요. 이 타입을 사용하면 공유가 완료됐을 때 지급할 리워드 정보를 확인할 수 있어요.\n * @property {'sendViral'} type - 이벤트의 타입이에요. `'sendViral'`은 사용자가 친구에게 공유를 완료했을 때 돌아와요.\n * @property {Object} data - 지급할 리워드 관련 정보를 담고 있어요.\n * @property {number} data.rewardAmount - 지급할 리워드 수량이에요. 앱인토스 콘솔에서 설정한 수량 및 금액 값이에요.\n * @property {string} data.rewardUnit - 리워드의 단위예요. 앱인토스 콘솔에 설정된 리워드 이름인 '하트', '보석' 등이 리워드 단위예요.\n */\nexport type RewardFromContactsViralEvent = {\n\ttype: \"sendViral\";\n\tdata: {\n\t\trewardAmount: number;\n\t\trewardUnit: string;\n\t};\n};\n/**\n * @public\n * @category 친구초대\n * @name ContactsViralSuccessEvent\n * @description 연락처 공유 모듈이 정상적으로 종료됐을 때 전달되는 이벤트 객체예요. 종료 이유와 함께 리워드 상태 및 남은 친구 수 등 관련 정보를 제공해요.\n * @property {'close'} type - 이벤트의 타입이에요. `'close'`는 공유 모듈이 종료됐을 때 돌아와요.\n * @property {Object} data - 모듈 종료와 관련된 세부 정보를 담고 있어요.\n * @property {'clickBackButton' | 'noReward'} data.closeReason - 모듈이 종료된 이유예요. `'clickBackButton'`은 사용자가 뒤로 가기 버튼을 눌러 종료한 경우이고, `'noReward'`는 받을 수 있는 리워드가 없어서 종료된 경우예요.\n * @property {number} data.sentRewardAmount - 사용자가 받은 전체 리워드 수량이에요.\n * @property {number} data.sendableRewardsCount - 아직 공유할 수 있는 친구 수예요.\n * @property {number} data.sentRewardsCount - 사용자가 공유를 완료한 친구 수예요.\n * @property {string} data.rewardUnit - 리워드의 단위예요. 앱인토스 콘솔에 설정된 리워드 이름인 '하트', '보석' 등이 리워드 단위예요.\n */\nexport type ContactsViralSuccessEvent = {\n\ttype: \"close\";\n\tdata: {\n\t\tcloseReason: \"clickBackButton\" | \"noReward\";\n\t\tsentRewardAmount?: number;\n\t\tsendableRewardsCount?: number;\n\t\tsentRewardsCount: number;\n\t\trewardUnit?: string;\n\t};\n};\nexport type ContactsViralEvent = RewardFromContactsViralEvent | ContactsViralSuccessEvent;\n/**\n * @public\n * @category 친구초대\n * @name ContactsViralOption\n * @description [연락처 공유 기능](/react-native/reference/native-modules/친구초대/contactsViral.html)을 사용할 때 필요한 옵션이에요.\n * @property {string} moduleId - 공유 리워드를 구분하는 UUID 형식의 고유 ID예요. 앱인토스 콘솔의 미니앱 > 공유 리워드 메뉴에서 확인할 수 있어요.\n */\nexport type ContactsViralOption = {\n\tmoduleId: string;\n};\n/**\n * @public\n * @category 친구초대\n * @name ContactsViralParams\n * @description `ContactsViralParams`는 연락처 공유 기능을 사용할 때 전달해야 하는 파라미터 타입이에요. 옵션을 설정하고, 이벤트 및 에러 처리 콜백을 지정할 수 있어요.\n * @property {ContactsViralOption} options - 공유 기능에 사용할 옵션 객체예요.\n * @property {(event: ContactsViralEvent) => void} onEvent - 공유 이벤트가 발생했을 때 실행되는 함수예요. [`RewardFromContactsViralEvent`](/bedrock/reference/native-modules/친구초대/RewardFromContactsViralEvent.html) 또는 [`ContactsViralSuccessEvent`](/react-native/reference/native-modules/친구초대/ContactsViralSuccessEvent.html) 타입의 이벤트 객체가 전달돼요.\n * @property {(error: unknown) => void} onError - 예기치 않은 에러가 발생했을 때 실행되는 함수예요.\n */\nexport interface ContactsViralParams {\n\toptions: ContactsViralOption;\n\tonEvent: (event: ContactsViralEvent) => void;\n\tonError: (error: unknown) => void;\n}\n/**\n * @public\n * @category 친구초대\n * @name contactsViral\n * @description 친구에게 공유하고 리워드를 받을 수 있는 기능을 제공해요. 사용자가 친구에게 공유를 완료하면 앱브릿지가 이벤트를 통해 리워드 정보를 전달해요.\n * @param {ContactsViralParams} params - 연락처 공유 기능을 실행할 때 사용하는 파라미터예요. 옵션 설정과 이벤트 핸들러를 포함해요. 자세한 내용은 [ContactsViralParams](/bedrock/reference/native-modules/친구초대/ContactsViralParams.html) 문서를 참고하세요.\n * @returns {() => void} 앱브릿지 cleanup 함수를 반환해요. 공유 기능이 끝나면 반드시 이 함수를 호출해서 리소스를 해제해야 해요.\n *\n * @example\n * ### 친구에게 공유하고 리워드 받기\n *\n * ```tsx\n * import { useCallback } from 'react';\n * import { Button } from 'react-native';\n * import { contactsViral } from '@apps-in-toss/framework';\n *\n * function ContactsViralButton({ moduleId }: { moduleId: string }) {\n *   const handleContactsViral = useCallback(() => {\n *     try {\n *       const cleanup = contactsViral({\n *         options: { moduleId: moduleId.trim() },\n *         onEvent: (event) => {\n *           if (event.type === 'sendViral') {\n *             console.log('리워드 지급:', event.data.rewardAmount, event.data.rewardUnit);\n *           } else if (event.type === 'close') {\n *             console.log('모듈 종료:', event.data.closeReason);\n *           }\n *         },\n *         onError: (error) => {\n *           console.error('에러 발생:', error);\n *         },\n *       });\n *\n *       return cleanup;\n *     } catch (error) {\n *       console.error('실행 중 에러:', error);\n *     }\n *   }, [moduleId]);\n *\n *   return <Button title=\"친구에게 공유하고 리워드 받기\" onPress={handleContactsViral} />;\n * }\n * ```\n */\nexport declare function contactsViral(params: ContactsViralParams): () => void;\n\nexport {};\n"
  },
  {
    "identifier": "startUpdateLocation",
    "dts": "declare enum Accuracy {\n\t/**\n\t * 오차범위 3KM 이내\n\t */\n\tLowest = 1,\n\t/**\n\t * 오차범위 1KM 이내\n\t */\n\tLow = 2,\n\t/**\n\t * 오차범위 몇 백미터 이내\n\t */\n\tBalanced = 3,\n\t/**\n\t * 오차범위 10M 이내\n\t */\n\tHigh = 4,\n\t/**\n\t * 가장 높은 정확도\n\t */\n\tHighest = 5,\n\t/**\n\t * 네비게이션을 위한 최고 정확도\n\t */\n\tBestForNavigation = 6\n}\ninterface Location$1 {\n\t/**\n\t * Android에서만 지원하는 옵션이에요.\n\t *\n\t * - `FINE`: 정확한 위치\n\t * - `COARSE`: 대략적인 위치\n\t *\n\t * @see https://developer.android.com/codelabs/approximate-location\n\t */\n\taccessLocation?: \"FINE\" | \"COARSE\";\n\t/**\n\t * 위치가 업데이트된 시점의 유닉스 타임스탬프예요.\n\t */\n\ttimestamp: number;\n\t/**\n\t * @description 위치 정보를 나타내는 객체예요. 자세한 내용은 [LocationCoords](/react-native/reference/native-modules/Types/LocationCoords.html)을 참고해주세요.\n\t */\n\tcoords: LocationCoords;\n}\n/**\n * @public\n * @category 위치 정보\n * @name LocationCoords\n * @description 세부 위치 정보를 나타내는 객체예요.\n */\nexport interface LocationCoords {\n\t/**\n\t * 위도\n\t */\n\tlatitude: number;\n\t/**\n\t * 경도\n\t */\n\tlongitude: number;\n\t/**\n\t * 높이\n\t */\n\taltitude: number;\n\t/**\n\t * 위치 정확도\n\t */\n\taccuracy: number;\n\t/**\n\t * 고도 정확도\n\t */\n\taltitudeAccuracy: number;\n\t/**\n\t * 방향\n\t */\n\theading: number;\n}\nexport interface StartUpdateLocationOptions {\n\t/**\n\t * 위치 정확도를 설정해요.\n\t */\n\taccuracy: Accuracy;\n\t/**\n\t * 위치 업데이트 주기를 밀리초(ms) 단위로 설정해요.\n\t */\n\ttimeInterval: number;\n\t/**\n\t * 위치 변경 거리를 미터(m) 단위로 설정해요.\n\t */\n\tdistanceInterval: number;\n}\nexport type StartUpdateLocationEventParams = {\n\tonEvent: (response: Location$1) => void;\n\tonError: (error: unknown) => void;\n\toptions: StartUpdateLocationOptions;\n};\ntype PermissionStatus$1 = \"notDetermined\" | \"denied\" | \"allowed\";\nexport type PermissionDialogFunction = () => Promise<Exclude<PermissionStatus$1, \"notDetermined\">>;\nexport type GetPermissionFunction = () => Promise<PermissionStatus$1>;\nexport interface EventEmitterSchema<K extends string, P extends unknown[]> {\n\tname: K;\n\tparams: P;\n}\n/**\n * @name UpdateLocationEventEmitter\n * @kind typedef\n * @description\n * 디바이스의 위치 정보 변경을 감지해요\n */\nexport type UpdateLocationEventEmitter = EventEmitterSchema<\"updateLocation\", [\n\tLocation$1\n]>;\n/**\n * @public\n * @category 위치 정보\n * @name startUpdateLocation\n * @description  디바이스의 위치 정보를 지속적으로 감지하고, 위치가 변경되면 콜백을 실행하는 함수예요. 콜백 함수를 등록하면 위치가 변경될 때마다 자동으로 호출돼요.\n * 실시간 위치 추적이 필요한 기능을 구현할 때 사용할 수 있어요. 예를 들어 지도 앱에서 사용자의 현재 위치를 실시간으로 업데이트할 때, 운동 앱에서 사용자의 이동 거리를 기록할 때 등이에요.\n * 위치 업데이트 주기와 정확도를 조정해 배터리 소모를 최소화하면서도 필요한 정보를 얻을 수 있어요.\n *\n *\n * @param {(error: unknown) => void} onError 위치 정보 감지에 실패했을 때 호출되는 콜백 함수예요.\n * @param {(location: Location) => void} onEvent 위치 정보가 변경될 때 호출되는 콜백 함수예요. 자세한 내용은 [Location](/react-native/reference/native-modules/Types/Location.html)을 참고해주세요.\n * @param {StartUpdateLocationOptions} options - 위치 정보 감지에 필요한 설정 객체에요.\n * @param {number} [options.accuracy] 위치 정확도를 설정해요.\n * @param {number} [options.timeInterval] 위치 정보를 업데이트하는 최소 주기로, 단위는 밀리초(ms)예요. 이 값은 위치 업데이트가 발생하는 가장 짧은 간격을 설정하지만, 시스템이나 환경의 영향을 받아 지정한 주기보다 더 긴 간격으로 업데이트될 수 있어요.\n * @param {number} [options.distanceInterval] 위치 변경 거리를 미터(m) 단위로 설정해요.\n *\n * @property [openPermissionDialog] - 위치 정보 권한을 다시 요청하는 다이얼로그를 표시해요. 사용자는 \"허용\", \"한 번만 허용\", \"안하기\" 중 하나를 선택할 수 있어요. \"허용\"이나 \"한 번만 허용\"을 선택하면 `allowed`를 반환하고, \"안하기\"를 선택하면 `denied`를 반환해요.\n * @property [getPermission] - 위치 정보 권한의 현재 상태를 반환해요. `allowed`는 사용자가 위치 정보 권한을 허용한 상태예요. `denied`는 사용자가 위치 정보 권한을 거부한 상태예요. `notDetermined`는 위치 정보 권한 요청을 한 번도 하지 않은 상태예요.\n *\n * @signature\n * ```typescript\n * function startUpdateLocation(options: {\n *   onError: (error: unknown) => void;\n *   onEvent: (location: Location) => void;\n *   options: StartUpdateLocationOptions;\n * }): () => void;\n * ```\n *\n * @example\n * ### 위치 정보 변경 감지하기\n *\n * 위치 정보가 변경되는것을 감지하는 예제예요. \"위치 정보 변경 감지하기\"를 눌러서 감지할 수 있어요.\n *\n * \"권한 확인하기\"버튼을 눌러서 현재 위치 정보 변경 감지 권한을 확인해요.\n * 사용자가 권한을 거부했거나 시스템에서 권한이 제한된 경우에는 [`StartUpdateLocationPermissionError`](/react-native/reference/types/권한/StartUpdateLocationPermissionError)를 반환해요.\n * \"권한 요청하기\"버튼을 눌러서 위치 정보 변경 감지 권한을 요청할 수 있어요.\n *\n * ```tsx\n * import { Accuracy, Location, startUpdateLocation, StartUpdateLocationPermissionError } from '@apps-in-toss/framework';\n * import { useCallback, useState } from 'react';\n * import { Alert, Button, Text, View } from 'react-native';\n *\n * // 위치 정보 변경 감지하기\n * function LocationWatcher() {\n *   const [location, setLocation] = useState<Location | null>(null);\n *\n *   const handlePress = useCallback(() => {\n *     startUpdateLocation({\n *       options: {\n *         accuracy: Accuracy.Balanced,\n *         timeInterval: 3000,\n *         distanceInterval: 10,\n *       },\n *       onEvent: (location) => {\n *         setLocation(location);\n *       },\n *       onError: (error) => {\n *         if (error instanceof StartUpdateLocationPermissionError) {\n *           // 위치 정보 변경 감지 권한 없음\n *         }\n *         console.error('위치 정보를 가져오는데 실패했어요:', error);\n *       },\n *     });\n *   }, []);\n *\n *   return (\n *     <View>\n *       {location != null && (\n *         <>\n *           <Text>위도: {location.coords.latitude}</Text>\n *           <Text>경도: {location.coords.longitude}</Text>\n *           <Text>위치 정확도: {location.coords.accuracy}m</Text>\n *           <Text>높이: {location.coords.altitude}m</Text>\n *           <Text>고도 정확도: {location.coords.altitudeAccuracy}m</Text>\n *           <Text>방향: {location.coords.heading}°</Text>\n *         </>\n *       )}\n *\n *       <Button title=\"위치 정보 변경 감지하기\" onPress={handlePress} />\n *\n *       <Button\n *         title=\"권한 확인하기\"\n *         onPress={async () => {\n *           const permission = await startUpdateLocation.getPermission();\n *           Alert.alert(permission);\n *         }}\n *       />\n *       <Button\n *         title=\"권한 요청하기\"\n *         onPress={async () => {\n *           const permission = await startUpdateLocation.openPermissionDialog();\n *           Alert.alert(permission);\n *         }}\n *       />\n *     </View>\n *   );\n * }\n * ```\n */\nexport declare function startUpdateLocation(eventParams: StartUpdateLocationEventParams): () => void;\nexport declare namespace startUpdateLocation {\n\tvar openPermissionDialog: PermissionDialogFunction;\n\tvar getPermission: GetPermissionFunction;\n}\n\nexport {};\n"
  },
  {
    "identifier": "onVisibilityChangedByTransparentServiceWeb",
    "dts": "import { EmitterSubscription } from 'react-native';\n\nexport interface EventEmitterSchema<K extends string, P extends unknown[]> {\n\tname: K;\n\tparams: P;\n}\nexport interface OnVisibilityChangedByTransparentServiceWebSubscription extends EmitterSubscription {\n\tremove: () => void;\n}\nexport type OnVisibilityChangedByTransparentServiceWebEventEmitter = EventEmitterSchema<\"visibilityChangedByTransparentServiceWeb\", [\n\tboolean\n]>;\nexport declare function onVisibilityChangedByTransparentServiceWeb(eventParams: {\n\toptions: {\n\t\tcallbackId: string;\n\t};\n\tonEvent: (isVisible: boolean) => void;\n\tonError: (error: unknown) => void;\n}): () => void;\n\nexport {};\n"
  },
  {
    "dts": "export type Primitive = string | number | boolean | null | undefined | symbol;\n\nexport {};\n"
  }
]