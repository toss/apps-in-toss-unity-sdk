// -----------------------------------------------------------------------
// <copyright file="AITCore.cs" company="Toss">
//     Copyright (c) Toss. All rights reserved.
//     Generated from @apps-in-toss/web-framework
// </copyright>
// -----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using UnityEngine;
using UnityEngine.Scripting;

namespace AppsInToss
{
    /// <summary>
    /// Shared JSON serialization settings for SDK.
    /// Uses StringEnumConverter to serialize enums as strings (matching JavaScript API expectations).
    /// Note: [JsonConverter(typeof(StringEnumConverter))] on enums causes IL2CPP infinite loop,
    /// so we configure it globally here instead.
    /// </summary>
    public static class AITJsonSettings
    {
        private static JsonSerializerSettings _settings;

        public static JsonSerializerSettings Default
        {
            get
            {
                if (_settings == null)
                {
                    _settings = new JsonSerializerSettings();
                    _settings.Converters.Add(new StringEnumConverter());
                }
                return _settings;
            }
        }

        /// <summary>
        /// Serialize object to JSON with enum-as-string support.
        /// </summary>
        public static string Serialize(object obj)
        {
            return JsonConvert.SerializeObject(obj, Default);
        }
    }

    /// <summary>
    /// Attribute to mark API methods with their category for grouping in UI.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public class APICategoryAttribute : Attribute
    {
        /// <summary>
        /// The category name (e.g., "Authentication", "Payment", "Location")
        /// </summary>
        public string Category { get; }

        public APICategoryAttribute(string category)
        {
            Category = category;
        }
    }

    /// <summary>
    /// Exception thrown when an Apps in Toss API call fails.
    /// Use try-catch to handle API errors in a C#-idiomatic way.
    /// </summary>
    public class AITException : Exception
    {
        /// <summary>The API name that failed</summary>
        public string APIName { get; }

        /// <summary>Error code for categorization (if available from platform)</summary>
        public string ErrorCode { get; }

        /// <summary>Whether this error is due to platform unavailability (browser environment)</summary>
        public bool IsPlatformUnavailable { get; }

        public AITException(string message) : base(message)
        {
            APIName = "";
            ErrorCode = "";
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        public AITException(string apiName, string message) : base(message)
        {
            APIName = apiName;
            ErrorCode = "";
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        public AITException(string apiName, string message, string errorCode) : base(message)
        {
            APIName = apiName;
            ErrorCode = errorCode;
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        public AITException(string message, Exception innerException) : base(message, innerException)
        {
            APIName = "";
            ErrorCode = "";
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        private static bool CheckPlatformUnavailable(string message)
        {
            if (string.IsNullOrEmpty(message)) return false;
            return message.Contains("__GRANITE_NATIVE_EMITTER") ||
                   message.Contains("ReactNativeWebView") ||
                   message.Contains("is not a constant handler");
        }
    }

    /// <summary>
    /// API response from JavaScript bridge.
    /// Uses explicit success/data/error format to avoid IL2CPP stripping issues.
    /// </summary>
    [Serializable]
    [Preserve]
    public class APIResponse
    {
        [Preserve]
        public bool success;
        [Preserve]
        public string data = "";
        [Preserve]
        public string error = "";
    }

    /// <summary>
    /// Apps in Toss SDK Core Infrastructure
    /// Callback management and JavaScript bridge
    /// </summary>
    public class AITCore : MonoBehaviour
    {
        private static AITCore _instance;

        /// <summary>
        /// Singleton instance
        /// </summary>
        public static AITCore Instance
        {
            get
            {
                if (_instance == null)
                {
                    var go = new GameObject("AITCore");
                    _instance = go.AddComponent<AITCore>();
                    UnityEngine.Object.DontDestroyOnLoad(go);
                }
                return _instance;
            }
        }

        // Callback storage: success callbacks and error callbacks
        private int _callbackIdCounter = 0;
        private Dictionary<string, Delegate> _callbacks = new Dictionary<string, Delegate>();
        private Dictionary<string, Action<AITException>> _errorCallbacks = new Dictionary<string, Action<AITException>>();

        /// <summary>
        /// Register success and error callbacks, return the callback ID.
        /// Used by async API methods with TaskCompletionSource.
        /// </summary>
        public string RegisterCallback<T>(Action<T> onSuccess, Action<AITException> onError)
        {
            string id = $"cb_{_callbackIdCounter++}";
            _callbacks[id] = onSuccess;
            _errorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Register a void callback (no parameters) and return its ID
        /// </summary>
        public string RegisterVoidCallback(Action onSuccess, Action<AITException> onError)
        {
            string id = $"cb_{_callbackIdCounter++}";
            // Wrap Action in Action<object> for storage
            _callbacks[id] = new Action<object>((_) => onSuccess?.Invoke());
            _errorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Try to get and remove a success callback by ID
        /// </summary>
        public bool TryGetCallback<T>(string callbackId, out Action<T> callback)
        {
            if (_callbacks.TryGetValue(callbackId, out var rawCallback))
            {
                callback = rawCallback as Action<T>;
                _callbacks.Remove(callbackId);
                _errorCallbacks.Remove(callbackId);
                return callback != null;
            }
            callback = null;
            return false;
        }

        /// <summary>
        /// Try to get and remove an error callback by ID
        /// </summary>
        public bool TryGetErrorCallback(string callbackId, out Action<AITException> callback)
        {
            if (_errorCallbacks.TryGetValue(callbackId, out callback))
            {
                _callbacks.Remove(callbackId);
                _errorCallbacks.Remove(callbackId);
                return callback != null;
            }
            callback = null;
            return false;
        }

        /// <summary>
        /// Remove callbacks without invoking them
        /// </summary>
        public void RemoveCallback(string callbackId)
        {
            _callbacks.Remove(callbackId);
            _errorCallbacks.Remove(callbackId);
        }

        // ===================================================================
        // Event Subscription System (persistent callbacks)
        // ===================================================================

        private int _subscriptionIdCounter = 0;
        private Dictionary<string, Delegate> _subscriptionCallbacks = new Dictionary<string, Delegate>();
        private Dictionary<string, Action<AITException>> _subscriptionErrorCallbacks = new Dictionary<string, Action<AITException>>();

        /// <summary>
        /// Register a subscription callback (not removed after invocation) - for events with data
        /// </summary>
        public string RegisterSubscriptionCallback<T>(Action<T> onEvent, Action<AITException> onError)
        {
            string id = $"sub_{_subscriptionIdCounter++}";
            _subscriptionCallbacks[id] = onEvent;
            if (onError != null) _subscriptionErrorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Register a void subscription callback - for events without data (backEvent, entryMessageExited)
        /// </summary>
        public string RegisterVoidSubscriptionCallback(Action onEvent, Action<AITException> onError)
        {
            string id = $"sub_{_subscriptionIdCounter++}";
            _subscriptionCallbacks[id] = onEvent;
            if (onError != null) _subscriptionErrorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Unsubscribe from an event
        /// </summary>
        public void Unsubscribe(string subscriptionId)
        {
            _subscriptionCallbacks.Remove(subscriptionId);
            _subscriptionErrorCallbacks.Remove(subscriptionId);

#if UNITY_WEBGL && !UNITY_EDITOR
            __AITUnsubscribe_Internal(subscriptionId);
#endif
        }

#if UNITY_WEBGL && !UNITY_EDITOR
        [System.Runtime.InteropServices.DllImport("__Internal")]
        private static extern void __AITUnsubscribe_Internal(string subscriptionId);
#endif

        /// <summary>
        /// Called by JavaScript when an event is triggered (persistent callback)
        /// </summary>
        public void OnAITEventCallback(string jsonPayload)
        {
            Debug.Log($"[AITCore] OnAITEventCallback received: {jsonPayload}");
            try
            {
                var callbackData = JsonConvert.DeserializeObject<CallbackData>(jsonPayload);
                Debug.Log($"[AITCore] Routing event callback: id={callbackData.CallbackId}, type={callbackData.TypeName}");
                RouteSubscriptionCallback(callbackData.CallbackId, callbackData.TypeName, callbackData.Result);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AITCore] Failed to process event callback: {ex.Message}");
            }
        }

        /// <summary>
        /// Route subscription callback (does NOT remove after invocation)
        /// </summary>
        private void RouteSubscriptionCallback(string callbackId, string typeName, string resultJson)
        {
            if (!_subscriptionCallbacks.TryGetValue(callbackId, out var rawCallback))
            {
                Debug.LogWarning($"[AITCore] Unknown subscription: {callbackId}");
                return;
            }

            var apiResponse = JsonConvert.DeserializeObject<APIResponse>(resultJson);

            if (apiResponse.success)
            {
                switch (typeName)
                {
                    case "TdsNavigationAccessoryEventData":
                        var tdsData = JsonConvert.DeserializeObject<TdsNavigationAccessoryEventData>(apiResponse.data);
                        (rawCallback as Action<TdsNavigationAccessoryEventData>)?.Invoke(tdsData);
                        break;
                    case "void":
                        // Void event - call Action directly
                        (rawCallback as Action)?.Invoke();
                        break;
                    default:
                        Debug.LogWarning($"[AITCore] Unknown subscription type: {typeName}");
                        break;
                }
            }
            else
            {
                if (_subscriptionErrorCallbacks.TryGetValue(callbackId, out var errorCallback))
                {
                    errorCallback?.Invoke(new AITException(typeName, apiResponse.error));
                }
            }
        }

        /// <summary>
        /// Called by JavaScript when a callback is triggered
        /// This is the entry point for all JavaScript -> Unity callbacks
        /// </summary>
        public void OnAITCallback(string jsonPayload)
        {
            Debug.Log($"[AITCore] OnAITCallback received: {jsonPayload}");
            try
            {
                var callbackData = JsonConvert.DeserializeObject<CallbackData>(jsonPayload);
                Debug.Log($"[AITCore] Routing callback: id={callbackData.CallbackId}, type={callbackData.TypeName}");
                RouteCallback(callbackData.CallbackId, callbackData.TypeName, callbackData.Result);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AITCore] Failed to process callback: {ex.Message}");
            }
        }

        /// <summary>
        /// Route callback based on type name.
        /// On success: calls callback with data.
        /// On error: calls error callback with AITException (causes Task to fault).
        /// </summary>
        private void RouteCallback(string callbackId, string typeName, string resultJson)
        {
            // Parse APIResponse first (success/data/error format)
            var apiResponse = JsonConvert.DeserializeObject<APIResponse>(resultJson);

            switch (typeName)
            {
{{#each callbackTypes}}
                case "{{this}}":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<{{this}}>(callbackId, out var callback{{@index}}) && callback{{@index}} != null)
                        {
                            var data{{@index}} = JsonConvert.DeserializeObject<{{this}}>(apiResponse.data);
                            callback{{@index}}(data{{@index}});
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var errorCallback{{@index}}) && errorCallback{{@index}} != null)
                        {
                            errorCallback{{@index}}(new AITException("{{this}}", apiResponse.error));
                        }
                    }
                    break;
{{/each}}
{{#each enumCallbackTypes}}
                case "{{this}}":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<{{this}}>(callbackId, out var enumCb_{{this}}) && enumCb_{{this}} != null)
                        {
                            // enum은 JsonUtility가 파싱 불가. Enum.TryParse 사용
                            var enumStr_{{this}} = apiResponse.data.Trim().Trim('"');
                            if (Enum.TryParse<{{this}}>(enumStr_{{this}}, true, out var enumVal_{{this}}))
                            {
                                enumCb_{{this}}(enumVal_{{this}});
                            }
                            else
                            {
                                Debug.LogWarning("[AITCore] Failed to parse enum {{this}}: " + enumStr_{{this}});
                            }
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var enumErrCb_{{this}}) && enumErrCb_{{this}} != null)
                        {
                            enumErrCb_{{this}}(new AITException("{{this}}", apiResponse.error));
                        }
                    }
                    break;
{{/each}}
                case "string":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<string>(callbackId, out var stringCallback) && stringCallback != null)
                        {
                            // string은 JsonUtility가 파싱 불가. data가 JSON 문자열이면 따옴표 제거
                            var stringData = apiResponse.data;
                            if (stringData.StartsWith("\"") && stringData.EndsWith("\""))
                            {
                                stringData = stringData.Substring(1, stringData.Length - 2);
                            }
                            stringCallback(stringData);
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var stringErrorCallback) && stringErrorCallback != null)
                        {
                            stringErrorCallback(new AITException("string", apiResponse.error));
                        }
                    }
                    break;
                case "bool":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<bool>(callbackId, out var boolCallback) && boolCallback != null)
                        {
                            // bool은 JsonUtility가 파싱 불가. 직접 파싱
                            var boolData = apiResponse.data.Trim().ToLower() == "true";
                            boolCallback(boolData);
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var boolErrorCallback) && boolErrorCallback != null)
                        {
                            boolErrorCallback(new AITException("bool", apiResponse.error));
                        }
                    }
                    break;
                case "double":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<double>(callbackId, out var doubleCallback) && doubleCallback != null)
                        {
                            // double은 JsonUtility가 파싱 불가. 직접 파싱
                            if (double.TryParse(apiResponse.data, out var doubleData))
                            {
                                doubleCallback(doubleData);
                            }
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var doubleErrorCallback) && doubleErrorCallback != null)
                        {
                            doubleErrorCallback(new AITException("double", apiResponse.error));
                        }
                    }
                    break;
                case "void":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<object>(callbackId, out var voidCallback) && voidCallback != null)
                        {
                            voidCallback(null);
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var voidErrorCallback) && voidErrorCallback != null)
                        {
                            voidErrorCallback(new AITException("void", apiResponse.error));
                        }
                    }
                    break;

                default:
                    Debug.LogWarning($"[AITCore] Unknown callback type: {typeName}");
                    break;
            }
        }
    }

    /// <summary>
    /// Callback payload from JavaScript
    /// </summary>
    [Serializable]
    [Preserve]
    public class CallbackData
    {
        [Preserve]
        public string CallbackId = "";
        [Preserve]
        public string TypeName = "";
        [Preserve]
        public string Result = "";
    }

    // ===================================================================
    // Event Data Types
    // ===================================================================

    /// <summary>
    /// TdsEvent navigationAccessoryEvent 데이터
    /// </summary>
    [Serializable]
    [Preserve]
    public class TdsNavigationAccessoryEventData
    {
        [Preserve]
        [JsonProperty("id")]
        public string Id;
    }
}
