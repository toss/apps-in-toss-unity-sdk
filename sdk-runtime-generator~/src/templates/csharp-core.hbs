// -----------------------------------------------------------------------
// <copyright file="AITCore.cs" company="Toss">
//     Copyright (c) Toss. All rights reserved.
//     Generated from @apps-in-toss/web-framework
// </copyright>
// -----------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using UnityEngine;
using UnityEngine.Scripting;

[assembly: InternalsVisibleTo("AppsInToss.Helpers")]

namespace AppsInToss
{
    /// <summary>
    /// Custom enum converter that handles both string and numeric enums:
    /// - Enums with [EnumMember] attributes: serialize as string (using EnumMember value)
    /// - Enums without [EnumMember] attributes: serialize as number (for numeric enums like Accuracy)
    /// </summary>
    public class SmartEnumConverter : JsonConverter
    {
        private readonly StringEnumConverter _stringConverter = new StringEnumConverter();

        public override bool CanConvert(Type objectType)
        {
            Type type = Nullable.GetUnderlyingType(objectType) ?? objectType;
            return type.IsEnum;
        }

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            if (value == null)
            {
                writer.WriteNull();
                return;
            }

            Type enumType = value.GetType();

            // Check if any member has EnumMember attribute
            bool hasEnumMember = false;
            foreach (var field in enumType.GetFields(BindingFlags.Public | BindingFlags.Static))
            {
                if (field.GetCustomAttribute<EnumMemberAttribute>() != null)
                {
                    hasEnumMember = true;
                    break;
                }
            }

            if (hasEnumMember)
            {
                // String enum: use StringEnumConverter
                _stringConverter.WriteJson(writer, value, serializer);
            }
            else
            {
                // Numeric enum: serialize as integer
                writer.WriteValue(Convert.ToInt32(value));
            }
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            // Delegate to StringEnumConverter for reading (handles both cases)
            return _stringConverter.ReadJson(reader, objectType, existingValue, serializer);
        }
    }

    /// <summary>
    /// Shared JSON serialization settings for SDK.
    /// Uses SmartEnumConverter to serialize:
    /// - String enums (with EnumMember): as strings matching JavaScript API expectations
    /// - Numeric enums (without EnumMember): as integers matching JavaScript API expectations
    /// Note: [JsonConverter] attribute on enums causes IL2CPP infinite loop, so we configure it globally here.
    /// </summary>
    public static class AITJsonSettings
    {
        private static JsonSerializerSettings _settings;

        public static JsonSerializerSettings Default
        {
            get
            {
                if (_settings == null)
                {
                    _settings = new JsonSerializerSettings();
                    _settings.Converters.Add(new SmartEnumConverter());
                }
                return _settings;
            }
        }

        /// <summary>
        /// Serialize object to JSON with smart enum support.
        /// </summary>
        public static string Serialize(object obj)
        {
            return JsonConvert.SerializeObject(obj, Default);
        }
    }

    /// <summary>
    /// Attribute to mark API methods with their category for grouping in UI.
    /// </summary>
    [AttributeUsage(AttributeTargets.Method)]
    public class APICategoryAttribute : Attribute
    {
        /// <summary>
        /// The category name (e.g., "Authentication", "Payment", "Location")
        /// </summary>
        public string Category { get; }

        public APICategoryAttribute(string category)
        {
            Category = category;
        }
    }

    /// <summary>
    /// Exception thrown when an Apps in Toss API call fails.
    /// Use try-catch to handle API errors in a C#-idiomatic way.
    /// </summary>
    public class AITException : Exception
    {
        /// <summary>The API name that failed</summary>
        public string APIName { get; }

        /// <summary>Error code for categorization (if available from platform)</summary>
        public string ErrorCode { get; }

        /// <summary>Whether this error is due to platform unavailability (browser environment)</summary>
        public bool IsPlatformUnavailable { get; }

        public AITException(string message) : base(message)
        {
            APIName = "";
            ErrorCode = "";
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        public AITException(string apiName, string message) : base(message)
        {
            APIName = apiName;
            ErrorCode = "";
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        public AITException(string apiName, string message, string errorCode) : base(message)
        {
            APIName = apiName;
            ErrorCode = errorCode;
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        public AITException(string message, Exception innerException) : base(message, innerException)
        {
            APIName = "";
            ErrorCode = "";
            IsPlatformUnavailable = CheckPlatformUnavailable(message);
        }

        private static bool CheckPlatformUnavailable(string message)
        {
            if (string.IsNullOrEmpty(message)) return false;
            return message.Contains("__GRANITE_NATIVE_EMITTER") ||
                   message.Contains("ReactNativeWebView") ||
                   message.Contains("is not a constant handler");
        }
    }

    /// <summary>
    /// API response from JavaScript bridge.
    /// Uses explicit success/data/error format to avoid IL2CPP stripping issues.
    /// </summary>
    [Serializable]
    [Preserve]
    public class APIResponse
    {
        [Preserve]
        public bool success;
        [Preserve]
        public string data = "";
        [Preserve]
        public string error = "";
    }

    /// <summary>
    /// Apps in Toss SDK Core Infrastructure
    /// Callback management and JavaScript bridge
    /// </summary>
    public class AITCore : MonoBehaviour
    {
        private static AITCore _instance;

        /// <summary>
        /// Singleton instance
        /// </summary>
        public static AITCore Instance
        {
            get
            {
                if (_instance == null)
                {
                    var go = new GameObject("AITCore");
                    _instance = go.AddComponent<AITCore>();
                    UnityEngine.Object.DontDestroyOnLoad(go);
                }
                return _instance;
            }
        }

        // Callback storage: success callbacks and error callbacks
        private int _callbackIdCounter = 0;
        private Dictionary<string, Delegate> _callbacks = new Dictionary<string, Delegate>();
        private Dictionary<string, Action<AITException>> _errorCallbacks = new Dictionary<string, Action<AITException>>();

        /// <summary>
        /// Register success and error callbacks, return the callback ID.
        /// Used by async API methods with TaskCompletionSource.
        /// </summary>
        public string RegisterCallback<T>(Action<T> onSuccess, Action<AITException> onError)
        {
            string id = $"cb_{_callbackIdCounter++}";
            _callbacks[id] = onSuccess;
            _errorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Register a void callback (no parameters) and return its ID
        /// </summary>
        public string RegisterVoidCallback(Action onSuccess, Action<AITException> onError)
        {
            string id = $"cb_{_callbackIdCounter++}";
            // Wrap Action in Action<object> for storage
            _callbacks[id] = new Action<object>((_) => onSuccess?.Invoke());
            _errorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Try to get and remove a success callback by ID
        /// </summary>
        public bool TryGetCallback<T>(string callbackId, out Action<T> callback)
        {
            if (_callbacks.TryGetValue(callbackId, out var rawCallback))
            {
                callback = rawCallback as Action<T>;
                _callbacks.Remove(callbackId);
                _errorCallbacks.Remove(callbackId);
                return callback != null;
            }
            callback = null;
            return false;
        }

        /// <summary>
        /// Try to get and remove an error callback by ID
        /// </summary>
        public bool TryGetErrorCallback(string callbackId, out Action<AITException> callback)
        {
            if (_errorCallbacks.TryGetValue(callbackId, out callback))
            {
                _callbacks.Remove(callbackId);
                _errorCallbacks.Remove(callbackId);
                return callback != null;
            }
            callback = null;
            return false;
        }

        /// <summary>
        /// Remove callbacks without invoking them
        /// </summary>
        public void RemoveCallback(string callbackId)
        {
            _callbacks.Remove(callbackId);
            _errorCallbacks.Remove(callbackId);
        }

        // ===================================================================
        // Event Subscription System (persistent callbacks)
        // ===================================================================

        private int _subscriptionIdCounter = 0;
        private Dictionary<string, Delegate> _subscriptionCallbacks = new Dictionary<string, Delegate>();
        private Dictionary<string, Action<AITException>> _subscriptionErrorCallbacks = new Dictionary<string, Action<AITException>>();

        /// <summary>
        /// Register a subscription callback (not removed after invocation) - for events with data
        /// </summary>
        public string RegisterSubscriptionCallback<T>(Action<T> onEvent, Action<AITException> onError)
        {
            string id = $"sub_{_subscriptionIdCounter++}";
            _subscriptionCallbacks[id] = onEvent;
            if (onError != null) _subscriptionErrorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Register a subscription callback with specified ID (for nested callback APIs)
        /// </summary>
        public void RegisterSubscriptionCallback<T>(string subscriptionId, Action<T> onEvent, Action<AITException> onError)
        {
            _subscriptionCallbacks[subscriptionId] = onEvent;
            if (onError != null) _subscriptionErrorCallbacks[subscriptionId] = onError;
        }

        /// <summary>
        /// Register a void subscription callback - for events without data (backEvent, entryMessageExited)
        /// </summary>
        public string RegisterVoidSubscriptionCallback(Action onEvent, Action<AITException> onError)
        {
            string id = $"sub_{_subscriptionIdCounter++}";
            _subscriptionCallbacks[id] = onEvent;
            if (onError != null) _subscriptionErrorCallbacks[id] = onError;
            return id;
        }

        /// <summary>
        /// Unsubscribe from an event
        /// </summary>
        public void Unsubscribe(string subscriptionId)
        {
            _subscriptionCallbacks.Remove(subscriptionId);
            _subscriptionErrorCallbacks.Remove(subscriptionId);

#if UNITY_WEBGL && !UNITY_EDITOR
            __AITUnsubscribe_Internal(subscriptionId);
#endif
        }

#if UNITY_WEBGL && !UNITY_EDITOR
        [System.Runtime.InteropServices.DllImport("__Internal")]
        private static extern void __AITUnsubscribe_Internal(string subscriptionId);
#endif

        /// <summary>
        /// Called by JavaScript when an event is triggered (persistent callback)
        /// </summary>
        public void OnAITEventCallback(string jsonPayload)
        {
            Debug.Log($"[AITCore] OnAITEventCallback received: {jsonPayload}");
            try
            {
                var callbackData = JsonConvert.DeserializeObject<CallbackData>(jsonPayload);
                Debug.Log($"[AITCore] Routing event callback: id={callbackData.CallbackId}, type={callbackData.TypeName}");
                RouteSubscriptionCallback(callbackData.CallbackId, callbackData.TypeName, callbackData.Result);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AITCore] Failed to process event callback: {ex.Message}");
            }
        }

        // ===================================================================
        // Visibility State Change Handler
        // ===================================================================

        /// <summary>
        /// Called by JavaScript when browser visibility state changes
        /// </summary>
        [Preserve]
        public void OnVisibilityStateChanged(string jsonPayload)
        {
            Debug.Log($"[AITCore] OnVisibilityStateChanged received: {jsonPayload}");
            try
            {
                var data = JsonConvert.DeserializeObject<VisibilityStateData>(jsonPayload);
                OnVisibilityStateChangedInternal?.Invoke(data.isVisible);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AITCore] Failed to process visibility state change: {ex.Message}");
            }
        }

        /// <summary>
        /// 내부 가시성 상태 변경 이벤트 (AITVisibilityHelper에서 구독)
        /// </summary>
        internal static event Action<bool> OnVisibilityStateChangedInternal;

        [Serializable]
        [Preserve]
        private class VisibilityStateData
        {
            [Preserve]
            public bool isVisible { get; set; }

            [Preserve]
            public VisibilityStateData() { }
        }

        /// <summary>
        /// Route subscription callback (does NOT remove after invocation)
        /// </summary>
        private void RouteSubscriptionCallback(string callbackId, string typeName, string resultJson)
        {
            if (!_subscriptionCallbacks.TryGetValue(callbackId, out var rawCallback))
            {
                Debug.LogWarning($"[AITCore] Unknown subscription: {callbackId}");
                return;
            }

            var apiResponse = JsonConvert.DeserializeObject<APIResponse>(resultJson);

            if (apiResponse.success)
            {
                switch (typeName)
                {
{{#each eventDataTypes}}
                    case "{{this}}":
                        var data_{{@index}} = JsonConvert.DeserializeObject<{{this}}>(apiResponse.data);
                        (rawCallback as Action<{{this}}>)?.Invoke(data_{{@index}});
                        break;
{{/each}}
                    case "void":
                        // Void event - call Action directly
                        (rawCallback as Action)?.Invoke();
                        break;
                    default:
                        Debug.LogWarning($"[AITCore] Unknown subscription type: {typeName}");
                        break;
                }
            }
            else
            {
                if (_subscriptionErrorCallbacks.TryGetValue(callbackId, out var errorCallback))
                {
                    errorCallback?.Invoke(new AITException(typeName, apiResponse.error));
                }
            }
        }

        /// <summary>
        /// Called by JavaScript when a callback is triggered
        /// This is the entry point for all JavaScript -> Unity callbacks
        /// </summary>
        public void OnAITCallback(string jsonPayload)
        {
            Debug.Log($"[AITCore] OnAITCallback received: {jsonPayload}");
            try
            {
                var callbackData = JsonConvert.DeserializeObject<CallbackData>(jsonPayload);
                Debug.Log($"[AITCore] Routing callback: id={callbackData.CallbackId}, type={callbackData.TypeName}");
                RouteCallback(callbackData.CallbackId, callbackData.TypeName, callbackData.Result);
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AITCore] Failed to process callback: {ex.Message}");
            }
        }

        /// <summary>
        /// Route callback based on type name.
        /// On success: calls callback with data.
        /// On error: calls error callback with AITException (causes Task to fault).
        /// </summary>
        private void RouteCallback(string callbackId, string typeName, string resultJson)
        {
            // Parse APIResponse first (success/data/error format)
            var apiResponse = JsonConvert.DeserializeObject<APIResponse>(resultJson);

            switch (typeName)
            {
{{#each callbackTypes}}
                case "{{this}}":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<{{this}}>(callbackId, out var callback{{@index}}) && callback{{@index}} != null)
                        {
                            var data{{@index}} = JsonConvert.DeserializeObject<{{this}}>(apiResponse.data);
                            callback{{@index}}(data{{@index}});
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var errorCallback{{@index}}) && errorCallback{{@index}} != null)
                        {
                            errorCallback{{@index}}(new AITException("{{this}}", apiResponse.error));
                        }
                    }
                    break;
{{/each}}
{{#each enumCallbackTypes}}
                case "{{this}}":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<{{this}}>(callbackId, out var enumCb_{{this}}) && enumCb_{{this}} != null)
                        {
                            // enum 파싱: 문자열에서 따옴표 제거 후 Enum.TryParse
                            var enumStr_{{this}} = apiResponse.data.Trim().Trim('"');
                            if (Enum.TryParse<{{this}}>(enumStr_{{this}}, true, out var enumVal_{{this}}))
                            {
                                enumCb_{{this}}(enumVal_{{this}});
                            }
                            else
                            {
                                Debug.LogWarning("[AITCore] Failed to parse enum {{this}}: " + enumStr_{{this}});
                                // 파싱 실패 시 에러 콜백 호출하여 Task 완료
                                if (TryGetErrorCallback(callbackId, out var parseErrCb_{{this}}) && parseErrCb_{{this}} != null)
                                {
                                    parseErrCb_{{this}}(new AITException("{{this}}", "Failed to parse enum value: " + enumStr_{{this}}));
                                }
                            }
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var enumErrCb_{{this}}) && enumErrCb_{{this}} != null)
                        {
                            enumErrCb_{{this}}(new AITException("{{this}}", apiResponse.error));
                        }
                    }
                    break;
{{/each}}
                case "string":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<string>(callbackId, out var stringCallback) && stringCallback != null)
                        {
                            // JSON 문자열에서 실제 문자열 추출 (따옴표 제거)
                            var stringData = apiResponse.data;
                            if (stringData.StartsWith("\"") && stringData.EndsWith("\"") && stringData.Length >= 2)
                            {
                                stringData = JsonConvert.DeserializeObject<string>(stringData);
                            }
                            stringCallback(stringData);
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var stringErrorCallback) && stringErrorCallback != null)
                        {
                            stringErrorCallback(new AITException("string", apiResponse.error));
                        }
                    }
                    break;
                case "bool":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<bool>(callbackId, out var boolCallback) && boolCallback != null)
                        {
                            // JSON에서 bool 파싱
                            var boolStr = apiResponse.data.Trim().ToLower();
                            var boolData = boolStr == "true";
                            boolCallback(boolData);
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var boolErrorCallback) && boolErrorCallback != null)
                        {
                            boolErrorCallback(new AITException("bool", apiResponse.error));
                        }
                    }
                    break;
                case "double":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<double>(callbackId, out var doubleCallback) && doubleCallback != null)
                        {
                            // JSON에서 double 파싱
                            double.TryParse(apiResponse.data.Trim(), out var doubleData);
                            doubleCallback(doubleData);
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var doubleErrorCallback) && doubleErrorCallback != null)
                        {
                            doubleErrorCallback(new AITException("double", apiResponse.error));
                        }
                    }
                    break;
                case "void":
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<object>(callbackId, out var voidCallback) && voidCallback != null)
                        {
                            voidCallback(null);
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var voidErrorCallback) && voidErrorCallback != null)
                        {
                            voidErrorCallback(new AITException("void", apiResponse.error));
                        }
                    }
                    break;
                case "System.Action":
                    // Disposer function return type - resolve Task with no-op Action
                    if (apiResponse.success)
                    {
                        if (TryGetCallback<System.Action>(callbackId, out var actionCallback) && actionCallback != null)
                        {
                            // Return an empty disposer - actual unsubscription handled by SDK
                            actionCallback(() => { });
                        }
                    }
                    else
                    {
                        if (TryGetErrorCallback(callbackId, out var actionErrorCallback) && actionErrorCallback != null)
                        {
                            actionErrorCallback(new AITException("System.Action", apiResponse.error));
                        }
                    }
                    break;

                default:
                    Debug.LogWarning($"[AITCore] Unknown callback type: {typeName}");
                    break;
            }
        }

        /// <summary>
        /// Callback payload from JavaScript
        /// </summary>
        [Serializable]
        [Preserve]
        public class CallbackData
        {
            [Preserve]
            public string CallbackId = "";
            [Preserve]
            public string TypeName = "";
            [Preserve]
            public string Result = "";
        }

        // ===================================================================
        // Nested Callback System (processProductGrant 등 options 내부 콜백)
        // ===================================================================

        private Dictionary<string, Delegate> _nestedCallbacks = new Dictionary<string, Delegate>();

        /// <summary>
        /// Register a nested callback (e.g., processProductGrant in IAPCreateOneTimePurchaseOrder)
        /// </summary>
        /// <param name="subscriptionId">Parent subscription ID</param>
        /// <param name="callbackName">Callback name (e.g., "processProductGrant")</param>
        /// <param name="callback">Callback function (Func&lt;T, bool&gt; or similar)</param>
        public void RegisterNestedCallback<TParam, TResult>(string subscriptionId, string callbackName, Func<TParam, TResult> callback)
        {
            var key = $"{subscriptionId}_{callbackName}";
            // Wrap the callback to accept JSON string and return bool
            Func<string, bool> wrapper = (string jsonData) => {
                try
                {
                    var param = JsonConvert.DeserializeObject<TParam>(jsonData);
                    var result = callback(param);
                    // Convert result to bool (handles bool, object, etc.)
                    if (result is bool boolResult) return boolResult;
                    return result != null;
                }
                catch (Exception ex)
                {
                    Debug.LogError($"[AITCore] Nested callback error: {ex.Message}");
                    return false;
                }
            };
            _nestedCallbacks[key] = wrapper;
            Debug.Log($"[AITCore] Registered nested callback: {key}");
        }

        /// <summary>
        /// Remove all nested callbacks for a subscription
        /// </summary>
        public void RemoveNestedCallbacks(string subscriptionId)
        {
            var keysToRemove = new List<string>();
            foreach (var key in _nestedCallbacks.Keys)
            {
                if (key.StartsWith(subscriptionId + "_"))
                {
                    keysToRemove.Add(key);
                }
            }
            foreach (var key in keysToRemove)
            {
                _nestedCallbacks.Remove(key);
                Debug.Log($"[AITCore] Removed nested callback: {key}");
            }
        }

        /// <summary>
        /// Called by JavaScript when a nested callback is triggered.
        /// JavaScript waits for the result via RespondToNestedCallback.
        /// </summary>
        public void OnNestedCallback(string jsonPayload)
        {
            Debug.Log($"[AITCore] OnNestedCallback received: {jsonPayload}");
            try
            {
                var request = JsonConvert.DeserializeObject<NestedCallbackRequest>(jsonPayload);
                var key = $"{request.CallbackId}_{request.CallbackName}";

                if (_nestedCallbacks.TryGetValue(key, out var rawCallback))
                {
                    // The stored callback is already a Func<string, bool> wrapper
                    if (rawCallback is Func<string, bool> callback)
                    {
                        bool result = callback(request.Data);
                        RespondToNestedCallback(request.RequestId, result);
                    }
                    else
                    {
                        Debug.LogError($"[AITCore] Callback is not a Func<string, bool>: {rawCallback.GetType()}");
                        RespondToNestedCallback(request.RequestId, false);
                    }
                }
                else
                {
                    Debug.LogWarning($"[AITCore] Unknown nested callback: {key}");
                    // Return false if callback not found
                    RespondToNestedCallback(request.RequestId, false);
                }
            }
            catch (Exception ex)
            {
                Debug.LogError($"[AITCore] Failed to process nested callback: {ex.Message}");
            }
        }

#if UNITY_WEBGL && !UNITY_EDITOR
        [System.Runtime.InteropServices.DllImport("__Internal")]
        private static extern void __AITRespondToNestedCallback(string requestId, int result);
#endif

        /// <summary>
        /// Send result back to JavaScript for a nested callback
        /// </summary>
        private void RespondToNestedCallback(string requestId, bool result)
        {
            Debug.Log($"[AITCore] RespondToNestedCallback: {requestId} = {result}");
#if UNITY_WEBGL && !UNITY_EDITOR
            __AITRespondToNestedCallback(requestId, result ? 1 : 0);
#endif
        }

        /// <summary>
        /// Nested callback request from JavaScript
        /// </summary>
        [Serializable]
        [Preserve]
        public class NestedCallbackRequest
        {
            [Preserve]
            [JsonProperty("requestId")]
            public string RequestId = "";
            [Preserve]
            [JsonProperty("callbackId")]
            public string CallbackId = "";
            [Preserve]
            [JsonProperty("callbackName")]
            public string CallbackName = "";
            [Preserve]
            [JsonProperty("data")]
            public string Data = "";
        }

    }

    // ===================================================================
    // Event Data Types
    // ===================================================================

    /// <summary>
    /// TdsEvent navigationAccessoryEvent 데이터
    /// </summary>
    [Serializable]
    [Preserve]
    public class TdsNavigationAccessoryEventData
    {
        [Preserve]
        [JsonProperty("id")]
        public string Id;
    }
}
